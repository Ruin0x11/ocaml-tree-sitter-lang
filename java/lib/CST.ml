(* Generated by ocaml-tree-sitter. *)
(*
   java grammar

   entrypoint: program
*)

open! Sexplib.Conv
open Tree_sitter_run

type reserved_identifier = [
    `Rese_id_open of Token.t (* "open" *)
  | `Rese_id_modu of Token.t (* "module" *)
]
[@@deriving sexp_of]

type floating_point_type = [
    `Floa_point_type_float of Token.t (* "float" *)
  | `Floa_point_type_doub of Token.t (* "double" *)
]
[@@deriving sexp_of]

type octal_integer_literal = Token.t
[@@deriving sexp_of]

type binary_integer_literal = Token.t
[@@deriving sexp_of]

type hex_integer_literal = Token.t
[@@deriving sexp_of]

type integral_type = [
    `Inte_type_byte of Token.t (* "byte" *)
  | `Inte_type_short of Token.t (* "short" *)
  | `Inte_type_int of Token.t (* "int" *)
  | `Inte_type_long of Token.t (* "long" *)
  | `Inte_type_char of Token.t (* "char" *)
]
[@@deriving sexp_of]

type decimal_floating_point_literal = Token.t
[@@deriving sexp_of]

type character_literal = Token.t
[@@deriving sexp_of]

type string_literal = Token.t
[@@deriving sexp_of]

type identifier = Token.t (* pattern [a-zA-Z_]\w* *)
[@@deriving sexp_of]

type hex_floating_point_literal = Token.t
[@@deriving sexp_of]

type decimal_integer_literal = Token.t
[@@deriving sexp_of]

type requires_modifier = [
    `Requis_modi_tran of Token.t (* "transitive" *)
  | `Requis_modi_stat of Token.t (* "static" *)
]
[@@deriving sexp_of]

type name = [
    `Name_id of identifier (*tok*)
  | `Name_rese_id of reserved_identifier
  | `Name_scop_id of (name * Token.t (* "." *) * identifier (*tok*))
]
[@@deriving sexp_of]

type inferred_parameters = (
    Token.t (* "(" *)
  * identifier (*tok*)
  * (Token.t (* "," *) * identifier (*tok*)) list (* zero or more *)
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type literal = [
    `Lit_deci_int_lit of decimal_integer_literal (*tok*)
  | `Lit_hex_int_lit of hex_integer_literal (*tok*)
  | `Lit_octal_int_lit of octal_integer_literal (*tok*)
  | `Lit_bin_int_lit of binary_integer_literal (*tok*)
  | `Lit_deci_floa_point_lit of decimal_floating_point_literal (*tok*)
  | `Lit_hex_floa_point_lit of hex_floating_point_literal (*tok*)
  | `Lit_true of Token.t (* "true" *)
  | `Lit_false of Token.t (* "false" *)
  | `Lit_char_lit of character_literal (*tok*)
  | `Lit_str_lit of string_literal (*tok*)
  | `Lit_null_lit of Token.t (* "null" *)
]
[@@deriving sexp_of]

type module_directive = (
    [
        `Requis_rep_requis_modi_name of (
            Token.t (* "requires" *)
          * requires_modifier list (* zero or more *)
          * name
        )
      | `Expors_name_opt_to_opt_name_rep_COMMA_name of (
            Token.t (* "exports" *)
          * name
          * Token.t (* "to" *) option
          * name option
          * (Token.t (* "," *) * name) list (* zero or more *)
        )
      | `Opens_name_opt_to_opt_name_rep_COMMA_name of (
            Token.t (* "opens" *)
          * name
          * Token.t (* "to" *) option
          * name option
          * (Token.t (* "," *) * name) list (* zero or more *)
        )
      | `Uses_name of (Token.t (* "uses" *) * name)
      | `Provis_name_with_name_rep_COMMA_name of (
            Token.t (* "provides" *)
          * name
          * Token.t (* "with" *)
          * name
          * (Token.t (* "," *) * name) list (* zero or more *)
        )
    ]
  * Token.t (* ";" *)
)
[@@deriving sexp_of]

type module_body = (
    Token.t (* "{" *)
  * module_directive list (* zero or more *)
  * Token.t (* "}" *)
)
[@@deriving sexp_of]

type expression = [
    `Exp_assign_exp of (
        [
            `Id of identifier (*tok*)
          | `Rese_id of reserved_identifier
          | `Field_acce of field_access
          | `Array_acce of array_access
        ]
      * [
            `EQ of Token.t (* "=" *)
          | `PLUSEQ of Token.t (* "+=" *)
          | `DASHEQ of Token.t (* "-=" *)
          | `STAREQ of Token.t (* "*=" *)
          | `SLASHEQ of Token.t (* "/=" *)
          | `AMPEQ of Token.t (* "&=" *)
          | `BAREQ of Token.t (* "|=" *)
          | `HATEQ of Token.t (* "^=" *)
          | `PERCEQ of Token.t (* "%=" *)
          | `LTLTEQ of Token.t (* "<<=" *)
          | `GTGTEQ of Token.t (* ">>=" *)
          | `GTGTGTEQ of Token.t (* ">>>=" *)
        ]
      * expression
    )
  | `Exp_bin_exp of binary_expression
  | `Exp_inst_exp of (expression * Token.t (* "instanceof" *) * type_)
  | `Exp_lamb_exp of (
        [
            `Id of identifier (*tok*)
          | `Form_params of formal_parameters
          | `Infe_params of inferred_parameters
        ]
      * Token.t (* "->" *)
      * [ `Exp of expression | `Blk of block ]
    )
  | `Exp_tern_exp of (
        expression * Token.t (* "?" *) * expression * Token.t (* ":" *)
      * expression
    )
  | `Exp_upda_exp of update_expression
  | `Exp_prim of primary
  | `Exp_un_exp of unary_expression
  | `Exp_cast_exp of (
        Token.t (* "(" *)
      * type_
      * (Token.t (* "&" *) * type_) list (* zero or more *)
      * Token.t (* ")" *)
      * expression
    )
]
and binary_expression = [
    `Bin_exp_exp_GT_exp of (expression * Token.t (* ">" *) * expression)
  | `Bin_exp_exp_LT_exp of (expression * Token.t (* "<" *) * expression)
  | `Bin_exp_exp_EQEQ_exp of (expression * Token.t (* "==" *) * expression)
  | `Bin_exp_exp_GTEQ_exp of (expression * Token.t (* ">=" *) * expression)
  | `Bin_exp_exp_LTEQ_exp of (expression * Token.t (* "<=" *) * expression)
  | `Bin_exp_exp_BANGEQ_exp of (expression * Token.t (* "!=" *) * expression)
  | `Bin_exp_exp_AMPAMP_exp of (expression * Token.t (* "&&" *) * expression)
  | `Bin_exp_exp_BARBAR_exp of (expression * Token.t (* "||" *) * expression)
  | `Bin_exp_exp_PLUS_exp of (expression * Token.t (* "+" *) * expression)
  | `Bin_exp_exp_DASH_exp of (expression * Token.t (* "-" *) * expression)
  | `Bin_exp_exp_STAR_exp of (expression * Token.t (* "*" *) * expression)
  | `Bin_exp_exp_SLASH_exp of (expression * Token.t (* "/" *) * expression)
  | `Bin_exp_exp_AMP_exp of (expression * Token.t (* "&" *) * expression)
  | `Bin_exp_exp_BAR_exp of (expression * Token.t (* "|" *) * expression)
  | `Bin_exp_exp_HAT_exp of (expression * Token.t (* "^" *) * expression)
  | `Bin_exp_exp_PERC_exp of (expression * Token.t (* "%" *) * expression)
  | `Bin_exp_exp_LTLT_exp of (expression * Token.t (* "<<" *) * expression)
  | `Bin_exp_exp_GTGT_exp of (expression * Token.t (* ">>" *) * expression)
  | `Bin_exp_exp_GTGTGT_exp of (
        expression * Token.t (* ">>>" *) * expression
    )
]
and unary_expression = [
    `Un_exp_PLUS_exp of (Token.t (* "+" *) * expression)
  | `Un_exp_DASH_exp of (Token.t (* "-" *) * expression)
  | `Un_exp_BANG_exp of (Token.t (* "!" *) * expression)
  | `Un_exp_TILDE_exp of (Token.t (* "~" *) * expression)
]
and update_expression = [
    `Exp_PLUSPLUS of (expression * Token.t (* "++" *))
  | `Exp_DASHDASH of (expression * Token.t (* "--" *))
  | `PLUSPLUS_exp of (Token.t (* "++" *) * expression)
  | `DASHDASH_exp of (Token.t (* "--" *) * expression)
]
and primary = [
    `Prim_lit of literal
  | `Prim_class_lit of (
        unannotated_type * Token.t (* "." *) * Token.t (* "class" *)
    )
  | `Prim_this of Token.t (* "this" *)
  | `Prim_id of identifier (*tok*)
  | `Prim_rese_id of reserved_identifier
  | `Prim_paren_exp of parenthesized_expression
  | `Prim_obj_crea_exp of object_creation_expression
  | `Prim_field_acce of field_access
  | `Prim_array_acce of array_access
  | `Prim_meth_invo of (
        [
            `Choice_id of [
                `Id of identifier (*tok*)
              | `Rese_id of reserved_identifier
            ]
          | `Choice_prim_DOT_opt_super_DOT_opt_type_args_choice_id of (
                [ `Prim of primary | `Super of Token.t (* "super" *) ]
              * Token.t (* "." *)
              * (Token.t (* "super" *) * Token.t (* "." *)) option
              * type_arguments option
              * [
                    `Id of identifier (*tok*)
                  | `Rese_id of reserved_identifier
                ]
            )
        ]
      * argument_list
    )
  | `Prim_meth_ref of (
        [
            `Type of type_
          | `Prim of primary
          | `Super of Token.t (* "super" *)
        ]
      * Token.t (* "::" *)
      * type_arguments option
      * [ `New of Token.t (* "new" *) | `Id of identifier (*tok*) ]
    )
  | `Prim_array_crea_exp of (
        Token.t (* "new" *)
      * simple_type
      * [
            `Rep1_dimens_expr_opt_dimens of (
                dimensions_expr list (* one or more *)
              * dimensions option
            )
          | `Dimens_array_init of (dimensions * array_initializer)
        ]
    )
]
and dimensions_expr = (
    annotation list (* zero or more *)
  * Token.t (* "[" *)
  * expression
  * Token.t (* "]" *)
)
and parenthesized_expression = (
    Token.t (* "(" *) * expression * Token.t (* ")" *)
)
and object_creation_expression = [
    `Obj_crea_exp_unqu_obj_crea_exp of unqualified_object_creation_expression
  | `Obj_crea_exp_prim_DOT_unqu_obj_crea_exp of (
        primary * Token.t (* "." *) * unqualified_object_creation_expression
    )
]
and unqualified_object_creation_expression = (
    Token.t (* "new" *)
  * type_arguments option
  * simple_type
  * argument_list
  * class_body option
)
and field_access = (
    [ `Prim of primary | `Super of Token.t (* "super" *) ]
  * (Token.t (* "." *) * Token.t (* "super" *)) option
  * Token.t (* "." *)
  * [
        `Id of identifier (*tok*)
      | `Rese_id of reserved_identifier
      | `This of Token.t (* "this" *)
    ]
)
and array_access = (
    primary * Token.t (* "[" *) * expression * Token.t (* "]" *)
)
and argument_list = (
    Token.t (* "(" *)
  * (expression * (Token.t (* "," *) * expression) list (* zero or more *))
      option
  * Token.t (* ")" *)
)
and type_arguments = (
    Token.t (* "<" *)
  * (
        [ `Type of type_ | `Wild of wildcard ]
      * (Token.t (* "," *) * [ `Type of type_ | `Wild of wildcard ])
          list (* zero or more *)
    )
      option
  * Token.t (* ">" *)
)
and wildcard = (
    annotation list (* zero or more *)
  * Token.t (* "?" *)
  * wildcard_bounds option
)
and wildcard_bounds = [
    `Wild_bounds_extens_type of (Token.t (* "extends" *) * type_)
  | `Wild_bounds_super_type of (Token.t (* "super" *) * type_)
]
and dimensions =
  (
      annotation list (* zero or more *)
    * Token.t (* "[" *)
    * Token.t (* "]" *)
  )
    list (* one or more *)
and statement = [
    `Stmt_decl of declaration
  | `Stmt_exp_stmt of (expression * Token.t (* ";" *))
  | `Stmt_labe_stmt of (identifier (*tok*) * Token.t (* ":" *) * statement)
  | `Stmt_if_stmt of (
        Token.t (* "if" *)
      * parenthesized_expression
      * statement
      * (Token.t (* "else" *) * statement) option
    )
  | `Stmt_while_stmt of (
        Token.t (* "while" *) * parenthesized_expression * statement
    )
  | `Stmt_for_stmt of (
        Token.t (* "for" *)
      * Token.t (* "(" *)
      * [
            `Local_var_decl of local_variable_declaration
          | `Opt_exp_rep_COMMA_exp_SEMI of (
                (
                    expression
                  * (Token.t (* "," *) * expression) list (* zero or more *)
                )
                  option
              * Token.t (* ";" *)
            )
        ]
      * expression option
      * Token.t (* ";" *)
      * (
            expression
          * (Token.t (* "," *) * expression) list (* zero or more *)
        )
          option
      * Token.t (* ")" *)
      * statement
    )
  | `Stmt_enha_for_stmt of (
        Token.t (* "for" *)
      * Token.t (* "(" *)
      * modifiers option
      * unannotated_type
      * variable_declarator_id
      * Token.t (* ":" *)
      * expression
      * Token.t (* ")" *)
      * statement
    )
  | `Stmt_blk of block
  | `Stmt_SEMI of Token.t (* ";" *)
  | `Stmt_asse_stmt of assert_statement
  | `Stmt_swit_stmt of (
        Token.t (* "switch" *) * parenthesized_expression * switch_block
    )
  | `Stmt_do_stmt of (
        Token.t (* "do" *) * statement * Token.t (* "while" *)
      * parenthesized_expression * Token.t (* ";" *)
    )
  | `Stmt_brk_stmt of (
        Token.t (* "break" *)
      * identifier (*tok*) option
      * Token.t (* ";" *)
    )
  | `Stmt_cont_stmt of (
        Token.t (* "continue" *)
      * identifier (*tok*) option
      * Token.t (* ";" *)
    )
  | `Stmt_ret_stmt of (
        Token.t (* "return" *)
      * expression option
      * Token.t (* ";" *)
    )
  | `Stmt_sync_stmt of (
        Token.t (* "synchronized" *) * parenthesized_expression * block
    )
  | `Stmt_local_var_decl of local_variable_declaration
  | `Stmt_throw_stmt of (
        Token.t (* "throw" *) * expression * Token.t (* ";" *)
    )
  | `Stmt_try_stmt of (
        Token.t (* "try" *)
      * block
      * [
            `Rep1_catch_clau of catch_clause list (* one or more *)
          | `Rep_catch_clau_fina_clau of (
                catch_clause list (* zero or more *)
              * finally_clause
            )
        ]
    )
  | `Stmt_try_with_resous_stmt of (
        Token.t (* "try" *)
      * resource_specification
      * block
      * catch_clause list (* zero or more *)
      * finally_clause option
    )
]
and block = (
    Token.t (* "{" *)
  * statement list (* zero or more *)
  * Token.t (* "}" *)
)
and assert_statement = [
    `Asse_stmt_asse_exp_SEMI of (
        Token.t (* "assert" *) * expression * Token.t (* ";" *)
    )
  | `Asse_stmt_asse_exp_COLON_exp_SEMI of (
        Token.t (* "assert" *) * expression * Token.t (* ":" *) * expression
      * Token.t (* ";" *)
    )
]
and switch_block = (
    Token.t (* "{" *)
  * [ `Swit_label of switch_label | `Stmt of statement ]
      list (* zero or more *)
  * Token.t (* "}" *)
)
and switch_label = [
    `Swit_label_case_exp_COLON of (
        Token.t (* "case" *) * expression * Token.t (* ":" *)
    )
  | `Swit_label_defa_COLON of (Token.t (* "default" *) * Token.t (* ":" *))
]
and catch_clause = (
    Token.t (* "catch" *) * Token.t (* "(" *) * catch_formal_parameter
  * Token.t (* ")" *) * block
)
and catch_formal_parameter = (
    modifiers option
  * catch_type
  * variable_declarator_id
)
and catch_type = (
    unannotated_type
  * (Token.t (* "|" *) * unannotated_type) list (* zero or more *)
)
and finally_clause = (Token.t (* "finally" *) * block)
and resource_specification = (
    Token.t (* "(" *)
  * resource
  * (Token.t (* ";" *) * resource) list (* zero or more *)
  * Token.t (* ";" *) option
  * Token.t (* ")" *)
)
and resource = [
    `Reso_opt_modifs_unan_type_var_decl_id_EQ_exp of (
        modifiers option
      * unannotated_type
      * variable_declarator_id
      * Token.t (* "=" *)
      * expression
    )
  | `Reso_id of identifier (*tok*)
  | `Reso_field_acce of field_access
]
and annotation = (Token.t (* "@" *) * name * annotation_argument_list)
and annotation_argument_list = (
    Token.t (* "(" *)
  * [
        `Elem_value of element_value
      | `Opt_elem_value_pair_rep_COMMA_elem_value_pair of
          (
              element_value_pair
            * (Token.t (* "," *) * element_value_pair)
                list (* zero or more *)
          )
            option
    ]
  * Token.t (* ")" *)
)
and element_value_pair = (
    identifier (*tok*) * Token.t (* "=" *) * element_value
)
and element_value = [
    `Exp of expression
  | `Elem_value_array_init of (
        Token.t (* "{" *)
      * (
            element_value
          * (Token.t (* "," *) * element_value) list (* zero or more *)
        )
          option
      * Token.t (* "," *) option
      * Token.t (* "}" *)
    )
  | `Anno of annotation
]
and declaration = [
    `Modu_decl of (
        annotation list (* zero or more *)
      * Token.t (* "open" *) option
      * Token.t (* "module" *)
      * name
      * module_body
    )
  | `Pack_decl of (
        annotation list (* zero or more *)
      * Token.t (* "package" *)
      * name
      * Token.t (* ";" *)
    )
  | `Impo_decl of (
        Token.t (* "import" *)
      * Token.t (* "static" *) option
      * name
      * (Token.t (* "." *) * Token.t (* "*" *)) option
      * Token.t (* ";" *)
    )
  | `Class_decl of class_declaration
  | `Inte_decl of interface_declaration
  | `Anno_type_decl of annotation_type_declaration
  | `Enum_decl of enum_declaration
]
and enum_declaration = (
    modifiers option
  * Token.t (* "enum" *)
  * identifier (*tok*)
  * super_interfaces option
  * enum_body
)
and enum_body = (
    Token.t (* "{" *)
  * (
        enum_constant
      * (Token.t (* "," *) * enum_constant) list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * enum_body_declarations option
  * Token.t (* "}" *)
)
and enum_body_declarations = (
    Token.t (* ";" *)
  * class_body_declaration list (* zero or more *)
)
and enum_constant = (
    modifiers option
  * identifier (*tok*)
  * argument_list option
  * class_body option
)
and class_declaration = (
    modifiers option
  * Token.t (* "class" *)
  * identifier (*tok*)
  * type_parameters option
  * superclass option
  * super_interfaces option
  * class_body
)
and modifiers =
  [
      `Anno of annotation
    | `Publ of Token.t (* "public" *)
    | `Prot of Token.t (* "protected" *)
    | `Priv of Token.t (* "private" *)
    | `Abst of Token.t (* "abstract" *)
    | `Stat of Token.t (* "static" *)
    | `Final of Token.t (* "final" *)
    | `Stri of Token.t (* "strictfp" *)
    | `Defa of Token.t (* "default" *)
    | `Sync of Token.t (* "synchronized" *)
    | `Nati of Token.t (* "native" *)
    | `Tran of Token.t (* "transient" *)
    | `Vola of Token.t (* "volatile" *)
  ]
    list (* one or more *)
and type_parameters = (
    Token.t (* "<" *)
  * type_parameter
  * (Token.t (* "," *) * type_parameter) list (* zero or more *)
  * Token.t (* ">" *)
)
and type_parameter = (
    annotation list (* zero or more *)
  * identifier (*tok*)
  * type_bound option
)
and type_bound = (
    Token.t (* "extends" *)
  * type_
  * (Token.t (* "&" *) * type_) list (* zero or more *)
)
and superclass = (Token.t (* "extends" *) * type_)
and super_interfaces = (Token.t (* "implements" *) * interface_type_list)
and interface_type_list = (
    type_
  * (Token.t (* "," *) * type_) list (* zero or more *)
)
and class_body = (
    Token.t (* "{" *)
  * class_body_declaration list (* zero or more *)
  * Token.t (* "}" *)
)
and class_body_declaration = [
    `Class_body_decl_field_decl of (
        modifiers option
      * unannotated_type
      * variable_declarator_list
      * Token.t (* ";" *)
    )
  | `Class_body_decl_meth_decl of method_declaration
  | `Class_body_decl_class_decl of class_declaration
  | `Class_body_decl_inte_decl of interface_declaration
  | `Class_body_decl_anno_type_decl of annotation_type_declaration
  | `Class_body_decl_enum_decl of enum_declaration
  | `Class_body_decl_blk of block
  | `Class_body_decl_stat_init of (Token.t (* "static" *) * block)
  | `Class_body_decl_cons_decl of (
        modifiers option
      * constructor_declarator
      * throws option
      * constructor_body
    )
  | `Class_body_decl_SEMI of Token.t (* ";" *)
]
and constructor_declarator = (
    type_parameters option
  * identifier (*tok*)
  * formal_parameters
)
and constructor_body = (
    Token.t (* "{" *)
  * explicit_constructor_invocation option
  * statement list (* zero or more *)
  * Token.t (* "}" *)
)
and explicit_constructor_invocation = (
    [
        `Opt_type_args_choice_this of (
            type_arguments option
          * [
                `This of Token.t (* "this" *)
              | `Super of Token.t (* "super" *)
            ]
        )
      | `Choice_prim_DOT_opt_type_args_super of (
            [ `Prim of primary ]
          * Token.t (* "." *)
          * type_arguments option
          * Token.t (* "super" *)
        )
    ]
  * argument_list
  * Token.t (* ";" *)
)
and annotation_type_declaration = (
    modifiers option
  * Token.t (* "@interface" *)
  * identifier (*tok*)
  * annotation_type_body
)
and annotation_type_body = (
    Token.t (* "{" *)
  * [
        `Anno_type_elem_decl of annotation_type_element_declaration
      | `Cst_decl of constant_declaration
      | `Class_decl of class_declaration
      | `Inte_decl of interface_declaration
      | `Anno_type_decl of annotation_type_declaration
    ]
      list (* zero or more *)
  * Token.t (* "}" *)
)
and annotation_type_element_declaration = (
    modifiers option
  * unannotated_type
  * identifier (*tok*)
  * Token.t (* "(" *)
  * Token.t (* ")" *)
  * dimensions option
  * default_value option
  * Token.t (* ";" *)
)
and default_value = (Token.t (* "default" *) * element_value)
and interface_declaration = (
    modifiers option
  * Token.t (* "interface" *)
  * identifier (*tok*)
  * type_parameters option
  * extends_interfaces option
  * interface_body
)
and extends_interfaces = (Token.t (* "extends" *) * interface_type_list)
and interface_body = (
    Token.t (* "{" *)
  * [
        `Cst_decl of constant_declaration
      | `Enum_decl of enum_declaration
      | `Meth_decl of method_declaration
      | `Class_decl of class_declaration
      | `Inte_decl of interface_declaration
      | `Anno_type_decl of annotation_type_declaration
      | `SEMI of Token.t (* ";" *)
    ]
      list (* zero or more *)
  * Token.t (* "}" *)
)
and constant_declaration = (
    modifiers option
  * unannotated_type
  * variable_declarator_list
  * Token.t (* ";" *)
)
and variable_declarator_list = (
    variable_declarator
  * (Token.t (* "," *) * variable_declarator) list (* zero or more *)
)
and variable_declarator = (
    variable_declarator_id
  * (Token.t (* "=" *) * variable_initializer) option
)
and variable_declarator_id = (
    [ `Id of identifier (*tok*) | `Rese_id of reserved_identifier ]
  * dimensions option
)
and variable_initializer = [
    `Var_init_exp of expression
  | `Var_init_array_init of array_initializer
]
and array_initializer = (
    Token.t (* "{" *)
  * (
        variable_initializer
      * (Token.t (* "," *) * variable_initializer) list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)
and type_ = [
    `Type_unan_type of unannotated_type
  | `Type_anno_type of (annotation list (* one or more *) * unannotated_type)
]
and unannotated_type = [
    `Unan_type_simple_type of simple_type
  | `Unan_type_array_type of (unannotated_type * dimensions)
]
and simple_type = [
    `Simple_type_void_type of Token.t (* "void" *)
  | `Simple_type_inte_type of integral_type
  | `Simple_type_floa_point_type of floating_point_type
  | `Simple_type_bool_type of Token.t (* "boolean" *)
  | `Simple_type_id of identifier (*tok*)
  | `Simple_type_scop_type_id of scoped_type_identifier
  | `Simple_type_gene_type of generic_type
]
and scoped_type_identifier = (
    [
        `Id of identifier (*tok*)
      | `Scop_type_id of scoped_type_identifier
      | `Gene_type of generic_type
    ]
  * Token.t (* "." *)
  * annotation list (* zero or more *)
  * identifier (*tok*)
)
and generic_type = (
    [ `Id of identifier (*tok*) | `Scop_type_id of scoped_type_identifier ]
  * type_arguments
)
and method_header = (
    (type_parameters * annotation list (* zero or more *)) option
  * unannotated_type
  * method_declarator
  * throws option
)
and method_declarator = (
    [ `Id of identifier (*tok*) | `Rese_id of reserved_identifier ]
  * formal_parameters
  * dimensions option
)
and formal_parameters = (
    Token.t (* "(" *)
  * receiver_parameter option
  * (
        [ `Form_param of formal_parameter | `Spre_param of spread_parameter ]
      * (
            Token.t (* "," *)
          * [
                `Form_param of formal_parameter
              | `Spre_param of spread_parameter
            ]
        )
          list (* zero or more *)
    )
      option
  * Token.t (* ")" *)
)
and formal_parameter = (
    modifiers option
  * unannotated_type
  * variable_declarator_id
)
and receiver_parameter = (
    annotation list (* zero or more *)
  * unannotated_type
  * (identifier (*tok*) * Token.t (* "." *)) option
  * Token.t (* "this" *)
)
and spread_parameter = (
    modifiers option
  * unannotated_type
  * Token.t (* "..." *)
  * variable_declarator
)
and throws = (
    Token.t (* "throws" *)
  * type_
  * (Token.t (* "," *) * type_) list (* zero or more *)
)
and local_variable_declaration = (
    modifiers option
  * unannotated_type
  * variable_declarator_list
  * Token.t (* ";" *)
)
and method_declaration = (
    modifiers option
  * method_header
  * [ `Blk of block | `SEMI of Token.t (* ";" *) ]
)
[@@deriving sexp_of]

type program = statement list (* zero or more *)
[@@deriving sexp_of]

type asterisk (* inlined *) = Token.t (* "*" *)
[@@deriving sexp_of]

type comment (* inlined *) = Token.t
[@@deriving sexp_of]

type super (* inlined *) = Token.t (* "super" *)
[@@deriving sexp_of]

type void_type (* inlined *) = Token.t (* "void" *)
[@@deriving sexp_of]

type boolean_type (* inlined *) = Token.t (* "boolean" *)
[@@deriving sexp_of]

type false_ (* inlined *) = Token.t (* "false" *)
[@@deriving sexp_of]

type null_literal (* inlined *) = Token.t (* "null" *)
[@@deriving sexp_of]

type true_ (* inlined *) = Token.t (* "true" *)
[@@deriving sexp_of]

type this (* inlined *) = Token.t (* "this" *)
[@@deriving sexp_of]

type scoped_identifier (* inlined *) = (
    name * Token.t (* "." *) * identifier (*tok*)
)
[@@deriving sexp_of]

type continue_statement (* inlined *) = (
    Token.t (* "continue" *)
  * identifier (*tok*) option
  * Token.t (* ";" *)
)
[@@deriving sexp_of]

type break_statement (* inlined *) = (
    Token.t (* "break" *)
  * identifier (*tok*) option
  * Token.t (* ";" *)
)
[@@deriving sexp_of]

type marker_annotation (* inlined *) = (Token.t (* "@" *) * name)
[@@deriving sexp_of]

type import_declaration (* inlined *) = (
    Token.t (* "import" *)
  * Token.t (* "static" *) option
  * name
  * (Token.t (* "." *) * Token.t (* "*" *)) option
  * Token.t (* ";" *)
)
[@@deriving sexp_of]

type cast_expression (* inlined *) = (
    Token.t (* "(" *)
  * type_
  * (Token.t (* "&" *) * type_) list (* zero or more *)
  * Token.t (* ")" *)
  * expression
)
[@@deriving sexp_of]

type assignment_expression (* inlined *) = (
    [
        `Id of identifier (*tok*)
      | `Rese_id of reserved_identifier
      | `Field_acce of field_access
      | `Array_acce of array_access
    ]
  * [
        `EQ of Token.t (* "=" *)
      | `PLUSEQ of Token.t (* "+=" *)
      | `DASHEQ of Token.t (* "-=" *)
      | `STAREQ of Token.t (* "*=" *)
      | `SLASHEQ of Token.t (* "/=" *)
      | `AMPEQ of Token.t (* "&=" *)
      | `BAREQ of Token.t (* "|=" *)
      | `HATEQ of Token.t (* "^=" *)
      | `PERCEQ of Token.t (* "%=" *)
      | `LTLTEQ of Token.t (* "<<=" *)
      | `GTGTEQ of Token.t (* ">>=" *)
      | `GTGTGTEQ of Token.t (* ">>>=" *)
    ]
  * expression
)
[@@deriving sexp_of]

type instanceof_expression (* inlined *) = (
    expression * Token.t (* "instanceof" *) * type_
)
[@@deriving sexp_of]

type lambda_expression (* inlined *) = (
    [
        `Id of identifier (*tok*)
      | `Form_params of formal_parameters
      | `Infe_params of inferred_parameters
    ]
  * Token.t (* "->" *)
  * [ `Exp of expression | `Blk of block ]
)
[@@deriving sexp_of]

type ternary_expression (* inlined *) = (
    expression * Token.t (* "?" *) * expression * Token.t (* ":" *)
  * expression
)
[@@deriving sexp_of]

type array_creation_expression (* inlined *) = (
    Token.t (* "new" *)
  * simple_type
  * [
        `Rep1_dimens_expr_opt_dimens of (
            dimensions_expr list (* one or more *)
          * dimensions option
        )
      | `Dimens_array_init of (dimensions * array_initializer)
    ]
)
[@@deriving sexp_of]

type class_literal (* inlined *) = (
    unannotated_type * Token.t (* "." *) * Token.t (* "class" *)
)
[@@deriving sexp_of]

type method_invocation (* inlined *) = (
    [
        `Choice_id of [
            `Id of identifier (*tok*)
          | `Rese_id of reserved_identifier
        ]
      | `Choice_prim_DOT_opt_super_DOT_opt_type_args_choice_id of (
            [ `Prim of primary | `Super of Token.t (* "super" *) ]
          * Token.t (* "." *)
          * (Token.t (* "super" *) * Token.t (* "." *)) option
          * type_arguments option
          * [ `Id of identifier (*tok*) | `Rese_id of reserved_identifier ]
        )
    ]
  * argument_list
)
[@@deriving sexp_of]

type method_reference (* inlined *) = (
    [ `Type of type_ | `Prim of primary | `Super of Token.t (* "super" *) ]
  * Token.t (* "::" *)
  * type_arguments option
  * [ `New of Token.t (* "new" *) | `Id of identifier (*tok*) ]
)
[@@deriving sexp_of]

type expression_statement (* inlined *) = (expression * Token.t (* ";" *))
[@@deriving sexp_of]

type labeled_statement (* inlined *) = (
    identifier (*tok*) * Token.t (* ":" *) * statement
)
[@@deriving sexp_of]

type switch_statement (* inlined *) = (
    Token.t (* "switch" *) * parenthesized_expression * switch_block
)
[@@deriving sexp_of]

type do_statement (* inlined *) = (
    Token.t (* "do" *) * statement * Token.t (* "while" *)
  * parenthesized_expression * Token.t (* ";" *)
)
[@@deriving sexp_of]

type return_statement (* inlined *) = (
    Token.t (* "return" *)
  * expression option
  * Token.t (* ";" *)
)
[@@deriving sexp_of]

type synchronized_statement (* inlined *) = (
    Token.t (* "synchronized" *) * parenthesized_expression * block
)
[@@deriving sexp_of]

type throw_statement (* inlined *) = (
    Token.t (* "throw" *) * expression * Token.t (* ";" *)
)
[@@deriving sexp_of]

type try_statement (* inlined *) = (
    Token.t (* "try" *)
  * block
  * [
        `Rep1_catch_clau of catch_clause list (* one or more *)
      | `Rep_catch_clau_fina_clau of (
            catch_clause list (* zero or more *)
          * finally_clause
        )
    ]
)
[@@deriving sexp_of]

type try_with_resources_statement (* inlined *) = (
    Token.t (* "try" *)
  * resource_specification
  * block
  * catch_clause list (* zero or more *)
  * finally_clause option
)
[@@deriving sexp_of]

type if_statement (* inlined *) = (
    Token.t (* "if" *)
  * parenthesized_expression
  * statement
  * (Token.t (* "else" *) * statement) option
)
[@@deriving sexp_of]

type while_statement (* inlined *) = (
    Token.t (* "while" *) * parenthesized_expression * statement
)
[@@deriving sexp_of]

type for_statement (* inlined *) = (
    Token.t (* "for" *)
  * Token.t (* "(" *)
  * [
        `Local_var_decl of local_variable_declaration
      | `Opt_exp_rep_COMMA_exp_SEMI of (
            (
                expression
              * (Token.t (* "," *) * expression) list (* zero or more *)
            )
              option
          * Token.t (* ";" *)
        )
    ]
  * expression option
  * Token.t (* ";" *)
  * (expression * (Token.t (* "," *) * expression) list (* zero or more *))
      option
  * Token.t (* ")" *)
  * statement
)
[@@deriving sexp_of]

type enhanced_for_statement (* inlined *) = (
    Token.t (* "for" *)
  * Token.t (* "(" *)
  * modifiers option
  * unannotated_type
  * variable_declarator_id
  * Token.t (* ":" *)
  * expression
  * Token.t (* ")" *)
  * statement
)
[@@deriving sexp_of]

type element_value_array_initializer (* inlined *) = (
    Token.t (* "{" *)
  * (
        element_value
      * (Token.t (* "," *) * element_value) list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)
[@@deriving sexp_of]

type module_declaration (* inlined *) = (
    annotation list (* zero or more *)
  * Token.t (* "open" *) option
  * Token.t (* "module" *)
  * name
  * module_body
)
[@@deriving sexp_of]

type package_declaration (* inlined *) = (
    annotation list (* zero or more *)
  * Token.t (* "package" *)
  * name
  * Token.t (* ";" *)
)
[@@deriving sexp_of]

type static_initializer (* inlined *) = (Token.t (* "static" *) * block)
[@@deriving sexp_of]

type constructor_declaration (* inlined *) = (
    modifiers option
  * constructor_declarator
  * throws option
  * constructor_body
)
[@@deriving sexp_of]

type field_declaration (* inlined *) = (
    modifiers option
  * unannotated_type
  * variable_declarator_list
  * Token.t (* ";" *)
)
[@@deriving sexp_of]

type annotated_type (* inlined *) = (
    annotation list (* one or more *)
  * unannotated_type
)
[@@deriving sexp_of]

type array_type (* inlined *) = (unannotated_type * dimensions)
[@@deriving sexp_of]

let dump_tree root =
  sexp_of_program root
  |> Print_sexp.to_stdout
