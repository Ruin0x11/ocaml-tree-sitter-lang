(* Generated by ocaml-tree-sitter. *)
(*
   typescript grammar

   entrypoint: program
*)

open! Sexplib.Conv
open Tree_sitter_run

type jsx_text = Token.t (* pattern [^{}<>]+ *)
[@@deriving sexp_of]

type meta_property = (
    Token.t (* "new" *) * Token.t (* "." *) * Token.t (* "target" *)
)
[@@deriving sexp_of]

type predefined_type = [
    `Pred_type_any of Token.t (* "any" *)
  | `Pred_type_num of Token.t (* "number" *)
  | `Pred_type_bool of Token.t (* "boolean" *)
  | `Pred_type_str of Token.t (* "string" *)
  | `Pred_type_symb of Token.t (* "symbol" *)
  | `Pred_type_void of Token.t (* "void" *)
]
[@@deriving sexp_of]

type template_chars = Token.t
[@@deriving sexp_of]

type regex_pattern = Token.t
[@@deriving sexp_of]

type escape_sequence = Token.t
[@@deriving sexp_of]

type number = Token.t
[@@deriving sexp_of]

type hash_bang_line = Token.t (* pattern #!.* *)
[@@deriving sexp_of]

type automatic_semicolon = Token.t
[@@deriving sexp_of]

type identifier = Token.t
[@@deriving sexp_of]

type import = Token.t
[@@deriving sexp_of]

type regex_flags = Token.t (* pattern [a-z]+ *)
[@@deriving sexp_of]

type accessibility_modifier = [
    `Publ of Token.t (* "public" *)
  | `Priv of Token.t (* "private" *)
  | `Prot of Token.t (* "protected" *)
]
[@@deriving sexp_of]

type jsx_identifier =
  Token.t (* pattern [a-zA-Z_$][a-zA-Z\d_$]*-[a-zA-Z\d_$\-]* *)
[@@deriving sexp_of]

type string_ = [
    `Str_DQUOT_rep_choice_blank_DQUOT of (
        Token.t (* "\"" *)
      * [ `Blank of unit (* blank *) | `Esc_seq of escape_sequence (*tok*) ]
          list (* zero or more *)
      * Token.t (* "\"" *)
    )
  | `Str_SQUOT_rep_choice_blank_SQUOT of (
        Token.t (* "'" *)
      * [ `Blank of unit (* blank *) | `Esc_seq of escape_sequence (*tok*) ]
          list (* zero or more *)
      * Token.t (* "'" *)
    )
]
[@@deriving sexp_of]

type debugger_statement = (
    Token.t (* "debugger" *)
  * [
        `Auto_semi of automatic_semicolon (*tok*)
      | `SEMI of Token.t (* ";" *)
    ]
)
[@@deriving sexp_of]

type continue_statement = (
    Token.t (* "continue" *)
  * identifier (*tok*) option
  * [
        `Auto_semi of automatic_semicolon (*tok*)
      | `SEMI of Token.t (* ";" *)
    ]
)
[@@deriving sexp_of]

type nested_identifier = (
    [ `Id of identifier (*tok*) | `Nest_id of nested_identifier ]
  * Token.t (* "." *)
  * identifier (*tok*)
)
[@@deriving sexp_of]

type import_export_specifier = (
    [
        `Type_599dcce of Token.t (* "type" *)
      | `Type_ac95254 of Token.t (* "typeof" *)
    ]
      option
  * identifier (*tok*)
  * (Token.t (* "as" *) * identifier (*tok*)) option
)
[@@deriving sexp_of]

type namespace_import = (
    Token.t (* "*" *) * Token.t (* "as" *) * identifier (*tok*)
)
[@@deriving sexp_of]

type break_statement = (
    Token.t (* "break" *)
  * identifier (*tok*) option
  * [
        `Auto_semi of automatic_semicolon (*tok*)
      | `SEMI of Token.t (* ";" *)
    ]
)
[@@deriving sexp_of]

type decorator_member_expression = (
    [
        `Choice_id of [
            `Id of identifier (*tok*)
          | `Choice_decl of [
                `Decl of Token.t (* "declare" *)
              | `Name of Token.t (* "namespace" *)
              | `Type of Token.t (* "type" *)
              | `Publ of Token.t (* "public" *)
              | `Priv of Token.t (* "private" *)
              | `Prot of Token.t (* "protected" *)
              | `Read of Token.t (* "readonly" *)
              | `Modu of Token.t (* "module" *)
              | `Any of Token.t (* "any" *)
              | `Num of Token.t (* "number" *)
              | `Bool of Token.t (* "boolean" *)
              | `Str of Token.t (* "string" *)
              | `Symb of Token.t (* "symbol" *)
              | `Void of Token.t (* "void" *)
              | `Expo of Token.t (* "export" *)
              | `Choice_get of [
                    `Get of Token.t (* "get" *)
                  | `Set of Token.t (* "set" *)
                  | `Async of Token.t (* "async" *)
                  | `Stat of Token.t (* "static" *)
                ]
            ]
        ]
      | `Deco_memb_exp of decorator_member_expression
    ]
  * Token.t (* "." *)
  * identifier (*tok*)
)
[@@deriving sexp_of]

type regex = (
    Token.t (* "/" *)
  * regex_pattern (*tok*)
  * Token.t (* "/" *)
  * regex_flags (*tok*) option
)
[@@deriving sexp_of]

type jsx_namespace_name = (
    [ `Jsx_id of jsx_identifier (*tok*) | `Id of identifier (*tok*) ]
  * Token.t (* ":" *)
  * [ `Jsx_id of jsx_identifier (*tok*) | `Id of identifier (*tok*) ]
)
[@@deriving sexp_of]

type import_require_clause = (
    identifier (*tok*) * Token.t (* "=" *) * Token.t (* "require" *)
  * Token.t (* "(" *) * string_ * Token.t (* ")" *)
)
[@@deriving sexp_of]

type from_clause = (Token.t (* "from" *) * string_)
[@@deriving sexp_of]

type literal_type = [
    `Lit_type_num_ of (
        [ `DASH of Token.t (* "-" *) | `PLUS of Token.t (* "+" *) ]
      * number (*tok*)
    )
  | `Lit_type_num of number (*tok*)
  | `Lit_type_str of string_
  | `Lit_type_true of Token.t (* "true" *)
  | `Lit_type_false of Token.t (* "false" *)
]
[@@deriving sexp_of]

type nested_type_identifier = (
    [ `Id of identifier (*tok*) | `Nest_id of nested_identifier ]
  * Token.t (* "." *)
  * identifier (*tok*)
)
[@@deriving sexp_of]

type export_clause = (
    Token.t (* "{" *)
  * (
        import_export_specifier
      * (Token.t (* "," *) * import_export_specifier) list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)
[@@deriving sexp_of]

type named_imports = (
    Token.t (* "{" *)
  * (
        import_export_specifier
      * (Token.t (* "," *) * import_export_specifier) list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)
[@@deriving sexp_of]

type jsx_closing_element = (
    Token.t (* "<" *)
  * Token.t (* "/" *)
  * [
        `Choice_jsx_id of [
            `Jsx_id of jsx_identifier (*tok*)
          | `Id of identifier (*tok*)
        ]
      | `Nest_id of nested_identifier
      | `Jsx_name_name of jsx_namespace_name
    ]
  * Token.t (* ">" *)
)
[@@deriving sexp_of]

type import_clause = [
    `Impo_clau_name_impo of namespace_import
  | `Impo_clau_named_impors of named_imports
  | `Impo_clau_id_opt_COMMA_choice_name_impo of (
        identifier (*tok*)
      * (
            Token.t (* "," *)
          * [
                `Name_impo of namespace_import
              | `Named_impors of named_imports
            ]
        )
          option
    )
]
[@@deriving sexp_of]

type import_statement = (
    Token.t (* "import" *)
  * [
        `Type_599dcce of Token.t (* "type" *)
      | `Type_ac95254 of Token.t (* "typeof" *)
    ]
      option
  * [
        `Impo_clau_from_clau of (import_clause * from_clause)
      | `Impo_requ_clau of import_require_clause
      | `Str of string_
    ]
  * [
        `Auto_semi of automatic_semicolon (*tok*)
      | `SEMI of Token.t (* ";" *)
    ]
)
[@@deriving sexp_of]

type export_statement = [
    `Choice_expo_choice_STAR_from_clau_choice_auto_semi of [
        `Expo_choice_STAR_from_clau_choice_auto_semi of (
            Token.t (* "export" *)
          * [
                `STAR_from_clau_choice_auto_semi of (
                    Token.t (* "*" *)
                  * from_clause
                  * [
                        `Auto_semi of automatic_semicolon (*tok*)
                      | `SEMI of Token.t (* ";" *)
                    ]
                )
              | `Expo_clau_from_clau_choice_auto_semi of (
                    export_clause
                  * from_clause
                  * [
                        `Auto_semi of automatic_semicolon (*tok*)
                      | `SEMI of Token.t (* ";" *)
                    ]
                )
              | `Expo_clau_choice_auto_semi of (
                    export_clause
                  * [
                        `Auto_semi of automatic_semicolon (*tok*)
                      | `SEMI of Token.t (* ";" *)
                    ]
                )
            ]
        )
      | `Rep_deco_expo_choice_decl of (
            decorator list (* zero or more *)
          * Token.t (* "export" *)
          * [
                `Decl of declaration
              | `Defa_exp_choice_auto_semi of (
                    Token.t (* "default" *)
                  * expression
                  * [
                        `Auto_semi of automatic_semicolon (*tok*)
                      | `SEMI of Token.t (* ";" *)
                    ]
                )
            ]
        )
    ]
  | `Expo_EQ_id_choice_auto_semi of (
        Token.t (* "export" *)
      * Token.t (* "=" *)
      * identifier (*tok*)
      * [
            `Auto_semi of automatic_semicolon (*tok*)
          | `SEMI of Token.t (* ";" *)
        ]
    )
  | `Expo_as_name_id_choice_auto_semi of (
        Token.t (* "export" *)
      * Token.t (* "as" *)
      * Token.t (* "namespace" *)
      * identifier (*tok*)
      * [
            `Auto_semi of automatic_semicolon (*tok*)
          | `SEMI of Token.t (* ";" *)
        ]
    )
]
and declaration = [
    `Decl_choice_func_decl of [
        `Func_decl of function_declaration
      | `Gene_func_decl of generator_function_declaration
      | `Class_decl of class_declaration
      | `Lexi_decl of lexical_declaration
      | `Var_decl of variable_declaration
    ]
  | `Decl_func_sign of (
        Token.t (* "async" *) option
      * Token.t (* "function" *)
      * identifier (*tok*)
      * call_signature
      * [
            `Auto_semi of automatic_semicolon (*tok*)
          | `SEMI of Token.t (* ";" *)
        ]
    )
  | `Decl_abst_class_decl of (
        Token.t (* "abstract" *)
      * Token.t (* "class" *)
      * identifier (*tok*)
      * type_parameters option
      * class_heritage option
      * class_body
    )
  | `Decl_modu of (Token.t (* "module" *) * module__)
  | `Decl_inte_modu of internal_module
  | `Decl_type_alias_decl of (
        Token.t (* "type" *)
      * identifier (*tok*)
      * type_parameters option
      * Token.t (* "=" *)
      * type_
      * [
            `Auto_semi of automatic_semicolon (*tok*)
          | `SEMI of Token.t (* ";" *)
        ]
    )
  | `Decl_enum_decl of (
        Token.t (* "const" *) option
      * Token.t (* "enum" *)
      * identifier (*tok*)
      * enum_body
    )
  | `Decl_inte_decl of (
        Token.t (* "interface" *)
      * identifier (*tok*)
      * type_parameters option
      * extends_clause option
      * object_type
    )
  | `Decl_impo_alias of (
        Token.t (* "import" *)
      * identifier (*tok*)
      * Token.t (* "=" *)
      * [ `Id of identifier (*tok*) | `Nest_id of nested_identifier ]
      * [
            `Auto_semi of automatic_semicolon (*tok*)
          | `SEMI of Token.t (* ";" *)
        ]
    )
  | `Decl_ambi_decl of (
        Token.t (* "declare" *)
      * [
            `Decl of declaration
          | `Glob_stmt_blk of (Token.t (* "global" *) * statement_block)
          | `Modu_DOT_id_COLON_type of (
                Token.t (* "module" *) * Token.t (* "." *)
              * identifier (*tok*) * Token.t (* ":" *) * type_
            )
        ]
    )
]
and expression_statement = (
    [ `Exp of expression | `Seq_exp of sequence_expression ]
  * [
        `Auto_semi of automatic_semicolon (*tok*)
      | `SEMI of Token.t (* ";" *)
    ]
)
and variable_declaration = (
    Token.t (* "var" *)
  * variable_declarator
  * (Token.t (* "," *) * variable_declarator) list (* zero or more *)
  * [
        `Auto_semi of automatic_semicolon (*tok*)
      | `SEMI of Token.t (* ";" *)
    ]
)
and lexical_declaration = (
    [ `Let of Token.t (* "let" *) | `Const of Token.t (* "const" *) ]
  * variable_declarator
  * (Token.t (* "," *) * variable_declarator) list (* zero or more *)
  * [
        `Auto_semi of automatic_semicolon (*tok*)
      | `SEMI of Token.t (* ";" *)
    ]
)
and variable_declarator = (
    [
        `Id of identifier (*tok*)
      | `Choice_obj of [ `Obj of object_ | `Array of array_ ]
    ]
  * type_annotation option
  * initializer_ option
)
and statement_block = (
    Token.t (* "{" *)
  * [
        `Expo_stmt of export_statement
      | `Impo_stmt of import_statement
      | `Debu_stmt of debugger_statement
      | `Exp_stmt of expression_statement
      | `Decl of declaration
      | `Stmt_blk of statement_block
      | `If_stmt of if_statement
      | `Swit_stmt of switch_statement
      | `For_stmt of for_statement
      | `For_in_stmt of for_in_statement
      | `While_stmt of while_statement
      | `Do_stmt of do_statement
      | `Try_stmt of try_statement
      | `With_stmt of with_statement
      | `Brk_stmt of break_statement
      | `Cont_stmt of continue_statement
      | `Ret_stmt of return_statement
      | `Throw_stmt of throw_statement
      | `Empty_stmt of Token.t (* ";" *)
      | `Labe_stmt of labeled_statement
    ]
      list (* zero or more *)
  * Token.t (* "}" *)
  * automatic_semicolon (*tok*) option
)
and if_statement = (
    Token.t (* "if" *)
  * parenthesized_expression
  * [
        `Expo_stmt of export_statement
      | `Impo_stmt of import_statement
      | `Debu_stmt of debugger_statement
      | `Exp_stmt of expression_statement
      | `Decl of declaration
      | `Stmt_blk of statement_block
      | `If_stmt of if_statement
      | `Swit_stmt of switch_statement
      | `For_stmt of for_statement
      | `For_in_stmt of for_in_statement
      | `While_stmt of while_statement
      | `Do_stmt of do_statement
      | `Try_stmt of try_statement
      | `With_stmt of with_statement
      | `Brk_stmt of break_statement
      | `Cont_stmt of continue_statement
      | `Ret_stmt of return_statement
      | `Throw_stmt of throw_statement
      | `Empty_stmt of Token.t (* ";" *)
      | `Labe_stmt of labeled_statement
    ]
  * (
        Token.t (* "else" *)
      * [
            `Expo_stmt of export_statement
          | `Impo_stmt of import_statement
          | `Debu_stmt of debugger_statement
          | `Exp_stmt of expression_statement
          | `Decl of declaration
          | `Stmt_blk of statement_block
          | `If_stmt of if_statement
          | `Swit_stmt of switch_statement
          | `For_stmt of for_statement
          | `For_in_stmt of for_in_statement
          | `While_stmt of while_statement
          | `Do_stmt of do_statement
          | `Try_stmt of try_statement
          | `With_stmt of with_statement
          | `Brk_stmt of break_statement
          | `Cont_stmt of continue_statement
          | `Ret_stmt of return_statement
          | `Throw_stmt of throw_statement
          | `Empty_stmt of Token.t (* ";" *)
          | `Labe_stmt of labeled_statement
        ]
    )
      option
)
and switch_statement = (
    Token.t (* "switch" *) * parenthesized_expression * switch_body
)
and for_statement = (
    Token.t (* "for" *)
  * Token.t (* "(" *)
  * [
        `Lexi_decl of lexical_declaration
      | `Var_decl of variable_declaration
      | `Exp_stmt of expression_statement
      | `Empty_stmt of Token.t (* ";" *)
    ]
  * [ `Exp_stmt of expression_statement | `Empty_stmt of Token.t (* ";" *) ]
  * [ `Exp of expression | `Seq_exp of sequence_expression ] option
  * Token.t (* ")" *)
  * [
        `Expo_stmt of export_statement
      | `Impo_stmt of import_statement
      | `Debu_stmt of debugger_statement
      | `Exp_stmt of expression_statement
      | `Decl of declaration
      | `Stmt_blk of statement_block
      | `If_stmt of if_statement
      | `Swit_stmt of switch_statement
      | `For_stmt of for_statement
      | `For_in_stmt of for_in_statement
      | `While_stmt of while_statement
      | `Do_stmt of do_statement
      | `Try_stmt of try_statement
      | `With_stmt of with_statement
      | `Brk_stmt of break_statement
      | `Cont_stmt of continue_statement
      | `Ret_stmt of return_statement
      | `Throw_stmt of throw_statement
      | `Empty_stmt of Token.t (* ";" *)
      | `Labe_stmt of labeled_statement
    ]
)
and for_in_statement = (
    Token.t (* "for" *)
  * Token.t (* "await" *) option
  * for_header
  * [
        `Expo_stmt of export_statement
      | `Impo_stmt of import_statement
      | `Debu_stmt of debugger_statement
      | `Exp_stmt of expression_statement
      | `Decl of declaration
      | `Stmt_blk of statement_block
      | `If_stmt of if_statement
      | `Swit_stmt of switch_statement
      | `For_stmt of for_statement
      | `For_in_stmt of for_in_statement
      | `While_stmt of while_statement
      | `Do_stmt of do_statement
      | `Try_stmt of try_statement
      | `With_stmt of with_statement
      | `Brk_stmt of break_statement
      | `Cont_stmt of continue_statement
      | `Ret_stmt of return_statement
      | `Throw_stmt of throw_statement
      | `Empty_stmt of Token.t (* ";" *)
      | `Labe_stmt of labeled_statement
    ]
)
and for_header = (
    Token.t (* "(" *)
  * [
        `Var of Token.t (* "var" *)
      | `Let of Token.t (* "let" *)
      | `Const of Token.t (* "const" *)
    ]
      option
  * [
        `Paren_exp of parenthesized_expression
      | `Choice_memb_exp of [
            `Memb_exp of member_expression
          | `Subs_exp of subscript_expression
          | `Id of identifier (*tok*)
          | `Choice_decl of [
                `Decl of Token.t (* "declare" *)
              | `Name of Token.t (* "namespace" *)
              | `Type of Token.t (* "type" *)
              | `Publ of Token.t (* "public" *)
              | `Priv of Token.t (* "private" *)
              | `Prot of Token.t (* "protected" *)
              | `Read of Token.t (* "readonly" *)
              | `Modu of Token.t (* "module" *)
              | `Any of Token.t (* "any" *)
              | `Num of Token.t (* "number" *)
              | `Bool of Token.t (* "boolean" *)
              | `Str of Token.t (* "string" *)
              | `Symb of Token.t (* "symbol" *)
              | `Void of Token.t (* "void" *)
              | `Expo of Token.t (* "export" *)
              | `Choice_get of [
                    `Get of Token.t (* "get" *)
                  | `Set of Token.t (* "set" *)
                  | `Async of Token.t (* "async" *)
                  | `Stat of Token.t (* "static" *)
                ]
            ]
          | `Choice_obj of [ `Obj of object_ | `Array of array_ ]
        ]
    ]
  * [ `In of Token.t (* "in" *) | `Of of Token.t (* "of" *) ]
  * [ `Exp of expression | `Seq_exp of sequence_expression ]
  * Token.t (* ")" *)
)
and while_statement = (
    Token.t (* "while" *)
  * parenthesized_expression
  * [
        `Expo_stmt of export_statement
      | `Impo_stmt of import_statement
      | `Debu_stmt of debugger_statement
      | `Exp_stmt of expression_statement
      | `Decl of declaration
      | `Stmt_blk of statement_block
      | `If_stmt of if_statement
      | `Swit_stmt of switch_statement
      | `For_stmt of for_statement
      | `For_in_stmt of for_in_statement
      | `While_stmt of while_statement
      | `Do_stmt of do_statement
      | `Try_stmt of try_statement
      | `With_stmt of with_statement
      | `Brk_stmt of break_statement
      | `Cont_stmt of continue_statement
      | `Ret_stmt of return_statement
      | `Throw_stmt of throw_statement
      | `Empty_stmt of Token.t (* ";" *)
      | `Labe_stmt of labeled_statement
    ]
)
and do_statement = (
    Token.t (* "do" *)
  * [
        `Expo_stmt of export_statement
      | `Impo_stmt of import_statement
      | `Debu_stmt of debugger_statement
      | `Exp_stmt of expression_statement
      | `Decl of declaration
      | `Stmt_blk of statement_block
      | `If_stmt of if_statement
      | `Swit_stmt of switch_statement
      | `For_stmt of for_statement
      | `For_in_stmt of for_in_statement
      | `While_stmt of while_statement
      | `Do_stmt of do_statement
      | `Try_stmt of try_statement
      | `With_stmt of with_statement
      | `Brk_stmt of break_statement
      | `Cont_stmt of continue_statement
      | `Ret_stmt of return_statement
      | `Throw_stmt of throw_statement
      | `Empty_stmt of Token.t (* ";" *)
      | `Labe_stmt of labeled_statement
    ]
  * Token.t (* "while" *)
  * parenthesized_expression
  * [
        `Auto_semi of automatic_semicolon (*tok*)
      | `SEMI of Token.t (* ";" *)
    ]
)
and try_statement = (
    Token.t (* "try" *)
  * statement_block
  * catch_clause option
  * finally_clause option
)
and with_statement = (
    Token.t (* "with" *)
  * parenthesized_expression
  * [
        `Expo_stmt of export_statement
      | `Impo_stmt of import_statement
      | `Debu_stmt of debugger_statement
      | `Exp_stmt of expression_statement
      | `Decl of declaration
      | `Stmt_blk of statement_block
      | `If_stmt of if_statement
      | `Swit_stmt of switch_statement
      | `For_stmt of for_statement
      | `For_in_stmt of for_in_statement
      | `While_stmt of while_statement
      | `Do_stmt of do_statement
      | `Try_stmt of try_statement
      | `With_stmt of with_statement
      | `Brk_stmt of break_statement
      | `Cont_stmt of continue_statement
      | `Ret_stmt of return_statement
      | `Throw_stmt of throw_statement
      | `Empty_stmt of Token.t (* ";" *)
      | `Labe_stmt of labeled_statement
    ]
)
and return_statement = (
    Token.t (* "return" *)
  * [ `Exp of expression | `Seq_exp of sequence_expression ] option
  * [
        `Auto_semi of automatic_semicolon (*tok*)
      | `SEMI of Token.t (* ";" *)
    ]
)
and throw_statement = (
    Token.t (* "throw" *)
  * [ `Exp of expression | `Seq_exp of sequence_expression ]
  * [
        `Auto_semi of automatic_semicolon (*tok*)
      | `SEMI of Token.t (* ";" *)
    ]
)
and labeled_statement = (
    [
        `Id of identifier (*tok*)
      | `Choice_decl of [
            `Decl of Token.t (* "declare" *)
          | `Name of Token.t (* "namespace" *)
          | `Type of Token.t (* "type" *)
          | `Publ of Token.t (* "public" *)
          | `Priv of Token.t (* "private" *)
          | `Prot of Token.t (* "protected" *)
          | `Read of Token.t (* "readonly" *)
          | `Modu of Token.t (* "module" *)
          | `Any of Token.t (* "any" *)
          | `Num of Token.t (* "number" *)
          | `Bool of Token.t (* "boolean" *)
          | `Str of Token.t (* "string" *)
          | `Symb of Token.t (* "symbol" *)
          | `Void of Token.t (* "void" *)
          | `Expo of Token.t (* "export" *)
          | `Choice_get of [
                `Get of Token.t (* "get" *)
              | `Set of Token.t (* "set" *)
              | `Async of Token.t (* "async" *)
              | `Stat of Token.t (* "static" *)
            ]
        ]
    ]
  * Token.t (* ":" *)
  * [
        `Expo_stmt of export_statement
      | `Impo_stmt of import_statement
      | `Debu_stmt of debugger_statement
      | `Exp_stmt of expression_statement
      | `Decl of declaration
      | `Stmt_blk of statement_block
      | `If_stmt of if_statement
      | `Swit_stmt of switch_statement
      | `For_stmt of for_statement
      | `For_in_stmt of for_in_statement
      | `While_stmt of while_statement
      | `Do_stmt of do_statement
      | `Try_stmt of try_statement
      | `With_stmt of with_statement
      | `Brk_stmt of break_statement
      | `Cont_stmt of continue_statement
      | `Ret_stmt of return_statement
      | `Throw_stmt of throw_statement
      | `Empty_stmt of Token.t (* ";" *)
      | `Labe_stmt of labeled_statement
    ]
)
and switch_body = (
    Token.t (* "{" *)
  * [ `Swit_case of switch_case | `Swit_defa of switch_default ]
      list (* zero or more *)
  * Token.t (* "}" *)
)
and switch_case = (
    Token.t (* "case" *)
  * [ `Exp of expression | `Seq_exp of sequence_expression ]
  * Token.t (* ":" *)
  * [
        `Expo_stmt of export_statement
      | `Impo_stmt of import_statement
      | `Debu_stmt of debugger_statement
      | `Exp_stmt of expression_statement
      | `Decl of declaration
      | `Stmt_blk of statement_block
      | `If_stmt of if_statement
      | `Swit_stmt of switch_statement
      | `For_stmt of for_statement
      | `For_in_stmt of for_in_statement
      | `While_stmt of while_statement
      | `Do_stmt of do_statement
      | `Try_stmt of try_statement
      | `With_stmt of with_statement
      | `Brk_stmt of break_statement
      | `Cont_stmt of continue_statement
      | `Ret_stmt of return_statement
      | `Throw_stmt of throw_statement
      | `Empty_stmt of Token.t (* ";" *)
      | `Labe_stmt of labeled_statement
    ]
      list (* zero or more *)
)
and switch_default = (
    Token.t (* "default" *)
  * Token.t (* ":" *)
  * [
        `Expo_stmt of export_statement
      | `Impo_stmt of import_statement
      | `Debu_stmt of debugger_statement
      | `Exp_stmt of expression_statement
      | `Decl of declaration
      | `Stmt_blk of statement_block
      | `If_stmt of if_statement
      | `Swit_stmt of switch_statement
      | `For_stmt of for_statement
      | `For_in_stmt of for_in_statement
      | `While_stmt of while_statement
      | `Do_stmt of do_statement
      | `Try_stmt of try_statement
      | `With_stmt of with_statement
      | `Brk_stmt of break_statement
      | `Cont_stmt of continue_statement
      | `Ret_stmt of return_statement
      | `Throw_stmt of throw_statement
      | `Empty_stmt of Token.t (* ";" *)
      | `Labe_stmt of labeled_statement
    ]
      list (* zero or more *)
)
and catch_clause = (
    Token.t (* "catch" *)
  * (
        Token.t (* "(" *)
      * [
            `Id of identifier (*tok*)
          | `Choice_obj of [ `Obj of object_ | `Array of array_ ]
        ]
      * Token.t (* ")" *)
    )
      option
  * statement_block
)
and finally_clause = (Token.t (* "finally" *) * statement_block)
and parenthesized_expression = (
    Token.t (* "(" *)
  * [
        `Exp_opt_type_anno of (expression * type_annotation option)
      | `Seq_exp of sequence_expression
    ]
  * Token.t (* ")" *)
)
and expression = [
    `Exp_as_exp of (
        expression
      * Token.t (* "as" *)
      * [ `Type of type_ | `Temp_str of template_string ]
    )
  | `Exp_non_null_exp of (expression * Token.t (* "!" *))
  | `Exp_inte_modu of internal_module
  | `Exp_super of Token.t (* "super" *)
  | `Exp_type_asse of (type_arguments * expression)
  | `Exp_choice_this of [
        `This of Token.t (* "this" *)
      | `Id of identifier (*tok*)
      | `Choice_decl of [
            `Decl of Token.t (* "declare" *)
          | `Name of Token.t (* "namespace" *)
          | `Type of Token.t (* "type" *)
          | `Publ of Token.t (* "public" *)
          | `Priv of Token.t (* "private" *)
          | `Prot of Token.t (* "protected" *)
          | `Read of Token.t (* "readonly" *)
          | `Modu of Token.t (* "module" *)
          | `Any of Token.t (* "any" *)
          | `Num of Token.t (* "number" *)
          | `Bool of Token.t (* "boolean" *)
          | `Str of Token.t (* "string" *)
          | `Symb of Token.t (* "symbol" *)
          | `Void of Token.t (* "void" *)
          | `Expo of Token.t (* "export" *)
          | `Choice_get of [
                `Get of Token.t (* "get" *)
              | `Set of Token.t (* "set" *)
              | `Async of Token.t (* "async" *)
              | `Stat of Token.t (* "static" *)
            ]
        ]
      | `Num of number (*tok*)
      | `Str of string_
      | `Temp_str of template_string
      | `Regex of regex
      | `True of Token.t (* "true" *)
      | `False of Token.t (* "false" *)
      | `Null of Token.t (* "null" *)
      | `Unde of Token.t (* "undefined" *)
      | `Impo of import (*tok*)
      | `Obj of object_
      | `Array of array_
      | `Func of function_
      | `Arrow_func of arrow_function
      | `Gene_func of generator_function
      | `Class of class_
      | `Paren_exp of parenthesized_expression
      | `Subs_exp of subscript_expression
      | `Memb_exp of member_expression
      | `Meta_prop of meta_property
      | `New_exp of new_expression
    ]
  | `Exp_assign_exp of (
        [
            `Paren_exp of parenthesized_expression
          | `Choice_memb_exp of [
                `Memb_exp of member_expression
              | `Subs_exp of subscript_expression
              | `Id of identifier (*tok*)
              | `Choice_decl of [
                    `Decl of Token.t (* "declare" *)
                  | `Name of Token.t (* "namespace" *)
                  | `Type of Token.t (* "type" *)
                  | `Publ of Token.t (* "public" *)
                  | `Priv of Token.t (* "private" *)
                  | `Prot of Token.t (* "protected" *)
                  | `Read of Token.t (* "readonly" *)
                  | `Modu of Token.t (* "module" *)
                  | `Any of Token.t (* "any" *)
                  | `Num of Token.t (* "number" *)
                  | `Bool of Token.t (* "boolean" *)
                  | `Str of Token.t (* "string" *)
                  | `Symb of Token.t (* "symbol" *)
                  | `Void of Token.t (* "void" *)
                  | `Expo of Token.t (* "export" *)
                  | `Choice_get of [
                        `Get of Token.t (* "get" *)
                      | `Set of Token.t (* "set" *)
                      | `Async of Token.t (* "async" *)
                      | `Stat of Token.t (* "static" *)
                    ]
                ]
              | `Choice_obj of [ `Obj of object_ | `Array of array_ ]
            ]
        ]
      * Token.t (* "=" *)
      * expression
    )
  | `Exp_augm_assign_exp of (
        [
            `Memb_exp of member_expression
          | `Subs_exp of subscript_expression
          | `Choice_decl of [
                `Decl of Token.t (* "declare" *)
              | `Name of Token.t (* "namespace" *)
              | `Type of Token.t (* "type" *)
              | `Publ of Token.t (* "public" *)
              | `Priv of Token.t (* "private" *)
              | `Prot of Token.t (* "protected" *)
              | `Read of Token.t (* "readonly" *)
              | `Modu of Token.t (* "module" *)
              | `Any of Token.t (* "any" *)
              | `Num of Token.t (* "number" *)
              | `Bool of Token.t (* "boolean" *)
              | `Str of Token.t (* "string" *)
              | `Symb of Token.t (* "symbol" *)
              | `Void of Token.t (* "void" *)
              | `Expo of Token.t (* "export" *)
              | `Choice_get of [
                    `Get of Token.t (* "get" *)
                  | `Set of Token.t (* "set" *)
                  | `Async of Token.t (* "async" *)
                  | `Stat of Token.t (* "static" *)
                ]
            ]
          | `Id of identifier (*tok*)
          | `Paren_exp of parenthesized_expression
        ]
      * [
            `PLUSEQ of Token.t (* "+=" *)
          | `DASHEQ of Token.t (* "-=" *)
          | `STAREQ of Token.t (* "*=" *)
          | `SLASHEQ of Token.t (* "/=" *)
          | `PERCEQ of Token.t (* "%=" *)
          | `HATEQ of Token.t (* "^=" *)
          | `AMPEQ of Token.t (* "&=" *)
          | `BAREQ of Token.t (* "|=" *)
          | `GTGTEQ of Token.t (* ">>=" *)
          | `GTGTGTEQ of Token.t (* ">>>=" *)
          | `LTLTEQ of Token.t (* "<<=" *)
          | `STARSTAREQ of Token.t (* "**=" *)
        ]
      * expression
    )
  | `Exp_await_exp of (Token.t (* "await" *) * expression)
  | `Exp_un_exp of unary_expression
  | `Exp_bin_exp of binary_expression
  | `Exp_tern_exp of (
        expression * Token.t (* "?" *) * expression * Token.t (* ":" *)
      * expression
    )
  | `Exp_upda_exp of update_expression
  | `Exp_call_exp of (
        [
            `Exp of expression
          | `Super of Token.t (* "super" *)
          | `Func of function_
        ]
      * type_arguments option
      * [ `Args of arguments | `Temp_str of template_string ]
    )
  | `Exp_yield_exp of (
        Token.t (* "yield" *)
      * [
            `STAR_exp of (Token.t (* "*" *) * expression)
          | `Opt_exp of expression option
        ]
    )
]
and object_ = (
    Token.t (* "{" *)
  * (
        [
            `Pair of pair
          | `Spre_elem of spread_element
          | `Meth_defi of method_definition
          | `Assign_pat of assignment_pattern
          | `Choice_id of [
                `Id of identifier (*tok*)
              | `Choice_decl of [
                    `Decl of Token.t (* "declare" *)
                  | `Name of Token.t (* "namespace" *)
                  | `Type of Token.t (* "type" *)
                  | `Publ of Token.t (* "public" *)
                  | `Priv of Token.t (* "private" *)
                  | `Prot of Token.t (* "protected" *)
                  | `Read of Token.t (* "readonly" *)
                  | `Modu of Token.t (* "module" *)
                  | `Any of Token.t (* "any" *)
                  | `Num of Token.t (* "number" *)
                  | `Bool of Token.t (* "boolean" *)
                  | `Str of Token.t (* "string" *)
                  | `Symb of Token.t (* "symbol" *)
                  | `Void of Token.t (* "void" *)
                  | `Expo of Token.t (* "export" *)
                  | `Choice_get of [
                        `Get of Token.t (* "get" *)
                      | `Set of Token.t (* "set" *)
                      | `Async of Token.t (* "async" *)
                      | `Stat of Token.t (* "static" *)
                    ]
                ]
            ]
        ]
          option
      * (
            Token.t (* "," *)
          * [
                `Pair of pair
              | `Spre_elem of spread_element
              | `Meth_defi of method_definition
              | `Assign_pat of assignment_pattern
              | `Choice_id of [
                    `Id of identifier (*tok*)
                  | `Choice_decl of [
                        `Decl of Token.t (* "declare" *)
                      | `Name of Token.t (* "namespace" *)
                      | `Type of Token.t (* "type" *)
                      | `Publ of Token.t (* "public" *)
                      | `Priv of Token.t (* "private" *)
                      | `Prot of Token.t (* "protected" *)
                      | `Read of Token.t (* "readonly" *)
                      | `Modu of Token.t (* "module" *)
                      | `Any of Token.t (* "any" *)
                      | `Num of Token.t (* "number" *)
                      | `Bool of Token.t (* "boolean" *)
                      | `Str of Token.t (* "string" *)
                      | `Symb of Token.t (* "symbol" *)
                      | `Void of Token.t (* "void" *)
                      | `Expo of Token.t (* "export" *)
                      | `Choice_get of [
                            `Get of Token.t (* "get" *)
                          | `Set of Token.t (* "set" *)
                          | `Async of Token.t (* "async" *)
                          | `Stat of Token.t (* "static" *)
                        ]
                    ]
                ]
            ]
              option
        )
          list (* zero or more *)
    )
      option
  * Token.t (* "}" *)
)
and assignment_pattern = (
    [
        `Choice_choice_decl of [
            `Choice_decl of [
                `Decl of Token.t (* "declare" *)
              | `Name of Token.t (* "namespace" *)
              | `Type of Token.t (* "type" *)
              | `Publ of Token.t (* "public" *)
              | `Priv of Token.t (* "private" *)
              | `Prot of Token.t (* "protected" *)
              | `Read of Token.t (* "readonly" *)
              | `Modu of Token.t (* "module" *)
              | `Any of Token.t (* "any" *)
              | `Num of Token.t (* "number" *)
              | `Bool of Token.t (* "boolean" *)
              | `Str of Token.t (* "string" *)
              | `Symb of Token.t (* "symbol" *)
              | `Void of Token.t (* "void" *)
              | `Expo of Token.t (* "export" *)
              | `Choice_get of [
                    `Get of Token.t (* "get" *)
                  | `Set of Token.t (* "set" *)
                  | `Async of Token.t (* "async" *)
                  | `Stat of Token.t (* "static" *)
                ]
            ]
          | `Id of identifier (*tok*)
        ]
      | `Choice_obj of [ `Obj of object_ | `Array of array_ ]
    ]
  * Token.t (* "=" *)
  * expression
)
and array_ = (
    Token.t (* "[" *)
  * (
        [ `Exp of expression | `Spre_elem of spread_element ] option
      * (
            Token.t (* "," *)
          * [ `Exp of expression | `Spre_elem of spread_element ] option
        )
          list (* zero or more *)
    )
      option
  * Token.t (* "]" *)
)
and class_ = (
    decorator list (* zero or more *)
  * Token.t (* "class" *)
  * identifier (*tok*) option
  * type_parameters option
  * class_heritage option
  * class_body
)
and class_declaration = (
    decorator list (* zero or more *)
  * Token.t (* "class" *)
  * identifier (*tok*)
  * type_parameters option
  * class_heritage option
  * class_body
  * automatic_semicolon (*tok*) option
)
and class_heritage = [
    `Class_heri_extens_clau_opt_imples_clau of (
        extends_clause
      * implements_clause option
    )
  | `Class_heri_imples_clau of implements_clause
]
and function_ = (
    Token.t (* "async" *) option
  * Token.t (* "function" *)
  * identifier (*tok*) option
  * call_signature
  * statement_block
)
and function_declaration = (
    Token.t (* "async" *) option
  * Token.t (* "function" *)
  * identifier (*tok*)
  * call_signature
  * statement_block
  * automatic_semicolon (*tok*) option
)
and generator_function = (
    Token.t (* "async" *) option
  * Token.t (* "function" *)
  * Token.t (* "*" *)
  * identifier (*tok*) option
  * call_signature
  * statement_block
)
and generator_function_declaration = (
    Token.t (* "async" *) option
  * Token.t (* "function" *)
  * Token.t (* "*" *)
  * identifier (*tok*)
  * call_signature
  * statement_block
  * automatic_semicolon (*tok*) option
)
and arrow_function = (
    Token.t (* "async" *) option
  * [
        `Choice_choice_decl of [
            `Choice_decl of [
                `Decl of Token.t (* "declare" *)
              | `Name of Token.t (* "namespace" *)
              | `Type of Token.t (* "type" *)
              | `Publ of Token.t (* "public" *)
              | `Priv of Token.t (* "private" *)
              | `Prot of Token.t (* "protected" *)
              | `Read of Token.t (* "readonly" *)
              | `Modu of Token.t (* "module" *)
              | `Any of Token.t (* "any" *)
              | `Num of Token.t (* "number" *)
              | `Bool of Token.t (* "boolean" *)
              | `Str of Token.t (* "string" *)
              | `Symb of Token.t (* "symbol" *)
              | `Void of Token.t (* "void" *)
              | `Expo of Token.t (* "export" *)
              | `Choice_get of [
                    `Get of Token.t (* "get" *)
                  | `Set of Token.t (* "set" *)
                  | `Async of Token.t (* "async" *)
                  | `Stat of Token.t (* "static" *)
                ]
            ]
          | `Id of identifier (*tok*)
        ]
      | `Call_sign of call_signature
    ]
  * Token.t (* "=>" *)
  * [ `Exp of expression | `Stmt_blk of statement_block ]
)
and call_signature = (
    type_parameters option
  * formal_parameters
  * type_annotation option
)
and new_expression = (
    Token.t (* "new" *)
  * [
        `This of Token.t (* "this" *)
      | `Id of identifier (*tok*)
      | `Choice_decl of [
            `Decl of Token.t (* "declare" *)
          | `Name of Token.t (* "namespace" *)
          | `Type of Token.t (* "type" *)
          | `Publ of Token.t (* "public" *)
          | `Priv of Token.t (* "private" *)
          | `Prot of Token.t (* "protected" *)
          | `Read of Token.t (* "readonly" *)
          | `Modu of Token.t (* "module" *)
          | `Any of Token.t (* "any" *)
          | `Num of Token.t (* "number" *)
          | `Bool of Token.t (* "boolean" *)
          | `Str of Token.t (* "string" *)
          | `Symb of Token.t (* "symbol" *)
          | `Void of Token.t (* "void" *)
          | `Expo of Token.t (* "export" *)
          | `Choice_get of [
                `Get of Token.t (* "get" *)
              | `Set of Token.t (* "set" *)
              | `Async of Token.t (* "async" *)
              | `Stat of Token.t (* "static" *)
            ]
        ]
      | `Num of number (*tok*)
      | `Str of string_
      | `Temp_str of template_string
      | `Regex of regex
      | `True of Token.t (* "true" *)
      | `False of Token.t (* "false" *)
      | `Null of Token.t (* "null" *)
      | `Unde of Token.t (* "undefined" *)
      | `Impo of import (*tok*)
      | `Obj of object_
      | `Array of array_
      | `Func of function_
      | `Arrow_func of arrow_function
      | `Gene_func of generator_function
      | `Class of class_
      | `Paren_exp of parenthesized_expression
      | `Subs_exp of subscript_expression
      | `Memb_exp of member_expression
      | `Meta_prop of meta_property
      | `New_exp of new_expression
    ]
  * arguments option
)
and member_expression = (
    [
        `Exp of expression
      | `Id of identifier (*tok*)
      | `Super of Token.t (* "super" *)
      | `Choice_decl of [
            `Decl of Token.t (* "declare" *)
          | `Name of Token.t (* "namespace" *)
          | `Type of Token.t (* "type" *)
          | `Publ of Token.t (* "public" *)
          | `Priv of Token.t (* "private" *)
          | `Prot of Token.t (* "protected" *)
          | `Read of Token.t (* "readonly" *)
          | `Modu of Token.t (* "module" *)
          | `Any of Token.t (* "any" *)
          | `Num of Token.t (* "number" *)
          | `Bool of Token.t (* "boolean" *)
          | `Str of Token.t (* "string" *)
          | `Symb of Token.t (* "symbol" *)
          | `Void of Token.t (* "void" *)
          | `Expo of Token.t (* "export" *)
          | `Choice_get of [
                `Get of Token.t (* "get" *)
              | `Set of Token.t (* "set" *)
              | `Async of Token.t (* "async" *)
              | `Stat of Token.t (* "static" *)
            ]
        ]
    ]
  * Token.t (* "." *)
  * identifier (*tok*)
)
and subscript_expression = (
    [ `Exp of expression | `Super of Token.t (* "super" *) ]
  * Token.t (* "[" *)
  * [ `Exp of expression | `Seq_exp of sequence_expression ]
  * Token.t (* "]" *)
)
and initializer_ = (Token.t (* "=" *) * expression)
and spread_element = (Token.t (* "..." *) * expression)
and binary_expression = [
    `Bin_exp_exp_AMPAMP_exp of (expression * Token.t (* "&&" *) * expression)
  | `Bin_exp_exp_BARBAR_exp of (expression * Token.t (* "||" *) * expression)
  | `Bin_exp_exp_GTGT_exp of (expression * Token.t (* ">>" *) * expression)
  | `Bin_exp_exp_GTGTGT_exp of (
        expression * Token.t (* ">>>" *) * expression
    )
  | `Bin_exp_exp_LTLT_exp of (expression * Token.t (* "<<" *) * expression)
  | `Bin_exp_exp_AMP_exp of (expression * Token.t (* "&" *) * expression)
  | `Bin_exp_exp_HAT_exp of (expression * Token.t (* "^" *) * expression)
  | `Bin_exp_exp_BAR_exp of (expression * Token.t (* "|" *) * expression)
  | `Bin_exp_exp_PLUS_exp of (expression * Token.t (* "+" *) * expression)
  | `Bin_exp_exp_DASH_exp of (expression * Token.t (* "-" *) * expression)
  | `Bin_exp_exp_STAR_exp of (expression * Token.t (* "*" *) * expression)
  | `Bin_exp_exp_SLASH_exp of (expression * Token.t (* "/" *) * expression)
  | `Bin_exp_exp_PERC_exp of (expression * Token.t (* "%" *) * expression)
  | `Bin_exp_exp_STARSTAR_exp of (
        expression * Token.t (* "**" *) * expression
    )
  | `Bin_exp_exp_LT_exp of (expression * Token.t (* "<" *) * expression)
  | `Bin_exp_exp_LTEQ_exp of (expression * Token.t (* "<=" *) * expression)
  | `Bin_exp_exp_EQEQ_exp of (expression * Token.t (* "==" *) * expression)
  | `Bin_exp_exp_EQEQEQ_exp of (
        expression * Token.t (* "===" *) * expression
    )
  | `Bin_exp_exp_BANGEQ_exp of (expression * Token.t (* "!=" *) * expression)
  | `Bin_exp_exp_BANGEQEQ_exp of (
        expression * Token.t (* "!==" *) * expression
    )
  | `Bin_exp_exp_GTEQ_exp of (expression * Token.t (* ">=" *) * expression)
  | `Bin_exp_exp_GT_exp of (expression * Token.t (* ">" *) * expression)
  | `Bin_exp_exp_QMARKQMARK_exp of (
        expression * Token.t (* "??" *) * expression
    )
  | `Bin_exp_exp_inst_exp of (
        expression * Token.t (* "instanceof" *) * expression
    )
  | `Bin_exp_exp_in_exp of (expression * Token.t (* "in" *) * expression)
]
and unary_expression = [
    `Un_exp_BANG_exp of (Token.t (* "!" *) * expression)
  | `Un_exp_TILDE_exp of (Token.t (* "~" *) * expression)
  | `Un_exp_DASH_exp of (Token.t (* "-" *) * expression)
  | `Un_exp_PLUS_exp of (Token.t (* "+" *) * expression)
  | `Un_exp_type_exp of (Token.t (* "typeof" *) * expression)
  | `Un_exp_void_exp of (Token.t (* "void" *) * expression)
  | `Un_exp_dele_exp of (Token.t (* "delete" *) * expression)
]
and update_expression = [
    `Exp_choice_PLUSPLUS of (
        expression
      * [ `PLUSPLUS of Token.t (* "++" *) | `DASHDASH of Token.t (* "--" *) ]
    )
  | `Choice_PLUSPLUS_exp of (
        [ `PLUSPLUS of Token.t (* "++" *) | `DASHDASH of Token.t (* "--" *) ]
      * expression
    )
]
and sequence_expression = (
    expression
  * Token.t (* "," *)
  * [ `Seq_exp of sequence_expression | `Exp of expression ]
)
and template_string = (
    Token.t (* "`" *)
  * [
        `Temp_chars of template_chars (*tok*)
      | `Esc_seq of escape_sequence (*tok*)
      | `Temp_subs of template_substitution
    ]
      list (* zero or more *)
  * Token.t (* "`" *)
)
and template_substitution = (
    Token.t (* "${" *)
  * [ `Exp of expression | `Seq_exp of sequence_expression ]
  * Token.t (* "}" *)
)
and arguments = (
    Token.t (* "(" *)
  * (
        [ `Exp of expression | `Spre_elem of spread_element ] option
      * (
            Token.t (* "," *)
          * [ `Exp of expression | `Spre_elem of spread_element ] option
        )
          list (* zero or more *)
    )
      option
  * Token.t (* ")" *)
)
and decorator = (
    Token.t (* "@" *)
  * [
        `Choice_id of [
            `Id of identifier (*tok*)
          | `Choice_decl of [
                `Decl of Token.t (* "declare" *)
              | `Name of Token.t (* "namespace" *)
              | `Type of Token.t (* "type" *)
              | `Publ of Token.t (* "public" *)
              | `Priv of Token.t (* "private" *)
              | `Prot of Token.t (* "protected" *)
              | `Read of Token.t (* "readonly" *)
              | `Modu of Token.t (* "module" *)
              | `Any of Token.t (* "any" *)
              | `Num of Token.t (* "number" *)
              | `Bool of Token.t (* "boolean" *)
              | `Str of Token.t (* "string" *)
              | `Symb of Token.t (* "symbol" *)
              | `Void of Token.t (* "void" *)
              | `Expo of Token.t (* "export" *)
              | `Choice_get of [
                    `Get of Token.t (* "get" *)
                  | `Set of Token.t (* "set" *)
                  | `Async of Token.t (* "async" *)
                  | `Stat of Token.t (* "static" *)
                ]
            ]
        ]
      | `Deco_memb_exp of decorator_member_expression
      | `Deco_call_exp of decorator_call_expression
    ]
)
and decorator_call_expression = (
    [
        `Choice_id of [
            `Id of identifier (*tok*)
          | `Choice_decl of [
                `Decl of Token.t (* "declare" *)
              | `Name of Token.t (* "namespace" *)
              | `Type of Token.t (* "type" *)
              | `Publ of Token.t (* "public" *)
              | `Priv of Token.t (* "private" *)
              | `Prot of Token.t (* "protected" *)
              | `Read of Token.t (* "readonly" *)
              | `Modu of Token.t (* "module" *)
              | `Any of Token.t (* "any" *)
              | `Num of Token.t (* "number" *)
              | `Bool of Token.t (* "boolean" *)
              | `Str of Token.t (* "string" *)
              | `Symb of Token.t (* "symbol" *)
              | `Void of Token.t (* "void" *)
              | `Expo of Token.t (* "export" *)
              | `Choice_get of [
                    `Get of Token.t (* "get" *)
                  | `Set of Token.t (* "set" *)
                  | `Async of Token.t (* "async" *)
                  | `Stat of Token.t (* "static" *)
                ]
            ]
        ]
      | `Deco_memb_exp of decorator_member_expression
    ]
  * arguments
)
and class_body = (
    Token.t (* "{" *)
  * [
        `Deco of decorator
      | `Meth_defi_opt_choice_auto_semi of (
            method_definition
          * [
                `Auto_semi of automatic_semicolon (*tok*)
              | `SEMI of Token.t (* ";" *)
            ]
              option
        )
      | `Choice_abst_meth_sign_choice_choice_auto_semi of (
            [
                `Abst_meth_sign of abstract_method_signature
              | `Index_sign of index_signature
              | `Meth_sign of method_signature
              | `Publ_field_defi of public_field_definition
            ]
          * [
                `Choice_auto_semi of [
                    `Auto_semi of automatic_semicolon (*tok*)
                  | `SEMI of Token.t (* ";" *)
                ]
              | `COMMA of Token.t (* "," *)
            ]
        )
    ]
      list (* zero or more *)
  * Token.t (* "}" *)
)
and public_field_definition = (
    accessibility_modifier option
  * [
        `Opt_stat_opt_read of (
            Token.t (* "static" *) option
          * Token.t (* "readonly" *) option
        )
      | `Opt_abst_opt_read of (
            Token.t (* "abstract" *) option
          * Token.t (* "readonly" *) option
        )
      | `Opt_read_opt_abst of (
            Token.t (* "readonly" *) option
          * Token.t (* "abstract" *) option
        )
    ]
  * property_name
  * [ `QMARK of Token.t (* "?" *) | `BANG of Token.t (* "!" *) ] option
  * type_annotation option
  * initializer_ option
)
and formal_parameters = (
    Token.t (* "(" *)
  * (
        decorator list (* zero or more *)
      * [
            `Requ_param of required_parameter
          | `Rest_param of rest_parameter
          | `Opt_param of optional_parameter
        ]
      * (
            Token.t (* "," *)
          * decorator list (* zero or more *)
          * [
                `Requ_param of required_parameter
              | `Rest_param of rest_parameter
              | `Opt_param of optional_parameter
            ]
        )
          list (* zero or more *)
      * Token.t (* "," *) option
    )
      option
  * Token.t (* ")" *)
)
and rest_parameter = (
    Token.t (* "..." *)
  * identifier (*tok*)
  * type_annotation option
)
and method_definition = (
    accessibility_modifier option
  * Token.t (* "static" *) option
  * Token.t (* "readonly" *) option
  * Token.t (* "async" *) option
  * [
        `Get of Token.t (* "get" *)
      | `Set of Token.t (* "set" *)
      | `STAR of Token.t (* "*" *)
    ]
      option
  * property_name
  * Token.t (* "?" *) option
  * call_signature
  * statement_block
)
and pair = (property_name * Token.t (* ":" *) * expression)
and property_name = [
    `Prop_name_choice_id of [
        `Id of identifier (*tok*)
      | `Choice_decl of [
            `Decl of Token.t (* "declare" *)
          | `Name of Token.t (* "namespace" *)
          | `Type of Token.t (* "type" *)
          | `Publ of Token.t (* "public" *)
          | `Priv of Token.t (* "private" *)
          | `Prot of Token.t (* "protected" *)
          | `Read of Token.t (* "readonly" *)
          | `Modu of Token.t (* "module" *)
          | `Any of Token.t (* "any" *)
          | `Num of Token.t (* "number" *)
          | `Bool of Token.t (* "boolean" *)
          | `Str of Token.t (* "string" *)
          | `Symb of Token.t (* "symbol" *)
          | `Void of Token.t (* "void" *)
          | `Expo of Token.t (* "export" *)
          | `Choice_get of [
                `Get of Token.t (* "get" *)
              | `Set of Token.t (* "set" *)
              | `Async of Token.t (* "async" *)
              | `Stat of Token.t (* "static" *)
            ]
        ]
    ]
  | `Prop_name_str of string_
  | `Prop_name_num of number (*tok*)
  | `Prop_name_comp_prop_name of (
        Token.t (* "[" *) * expression * Token.t (* "]" *)
    )
]
and method_signature = (
    accessibility_modifier option
  * Token.t (* "static" *) option
  * Token.t (* "readonly" *) option
  * Token.t (* "async" *) option
  * [
        `Get of Token.t (* "get" *)
      | `Set of Token.t (* "set" *)
      | `STAR of Token.t (* "*" *)
    ]
      option
  * property_name
  * Token.t (* "?" *) option
  * call_signature
)
and abstract_method_signature = (
    accessibility_modifier option
  * Token.t (* "abstract" *)
  * [
        `Get of Token.t (* "get" *)
      | `Set of Token.t (* "set" *)
      | `STAR of Token.t (* "*" *)
    ]
      option
  * property_name
  * Token.t (* "?" *) option
  * call_signature
)
and implements_clause = (
    Token.t (* "implements" *)
  * type_
  * (Token.t (* "," *) * type_) list (* zero or more *)
)
and internal_module = (Token.t (* "namespace" *) * module__)
and module__ = (
    [
        `Str of string_
      | `Id of identifier (*tok*)
      | `Nest_id of nested_identifier
    ]
  * statement_block option
)
and extends_clause = (
    Token.t (* "extends" *)
  * [
        `Choice_id of [
            `Id of identifier (*tok*)
          | `Nest_type_id of nested_type_identifier
          | `Gene_type of generic_type
        ]
      | `Exp of expression
    ]
  * (
        Token.t (* "," *)
      * [
            `Choice_id of [
                `Id of identifier (*tok*)
              | `Nest_type_id of nested_type_identifier
              | `Gene_type of generic_type
            ]
          | `Exp of expression
        ]
    )
      list (* zero or more *)
)
and enum_body = (
    Token.t (* "{" *)
  * (
        [ `Prop_name of property_name | `Enum_assign of enum_assignment ]
      * (
            Token.t (* "," *)
          * [ `Prop_name of property_name | `Enum_assign of enum_assignment ]
        )
          list (* zero or more *)
      * Token.t (* "," *) option
    )
      option
  * Token.t (* "}" *)
)
and enum_assignment = (property_name * initializer_)
and required_parameter = (
    parameter_name
  * type_annotation option
  * initializer_ option
)
and optional_parameter = (
    parameter_name
  * Token.t (* "?" *)
  * type_annotation option
  * initializer_ option
)
and parameter_name = (
    accessibility_modifier option
  * Token.t (* "readonly" *) option
  * [
        `Id of identifier (*tok*)
      | `Choice_decl of [
            `Decl of Token.t (* "declare" *)
          | `Name of Token.t (* "namespace" *)
          | `Type of Token.t (* "type" *)
          | `Publ of Token.t (* "public" *)
          | `Priv of Token.t (* "private" *)
          | `Prot of Token.t (* "protected" *)
          | `Read of Token.t (* "readonly" *)
          | `Modu of Token.t (* "module" *)
          | `Any of Token.t (* "any" *)
          | `Num of Token.t (* "number" *)
          | `Bool of Token.t (* "boolean" *)
          | `Str of Token.t (* "string" *)
          | `Symb of Token.t (* "symbol" *)
          | `Void of Token.t (* "void" *)
          | `Expo of Token.t (* "export" *)
          | `Choice_get of [
                `Get of Token.t (* "get" *)
              | `Set of Token.t (* "set" *)
              | `Async of Token.t (* "async" *)
              | `Stat of Token.t (* "static" *)
            ]
        ]
      | `Choice_obj of [ `Obj of object_ | `Array of array_ ]
      | `This of Token.t (* "this" *)
    ]
)
and type_annotation = (Token.t (* ":" *) * type_)
and type_ = [
    `Type_prim_type of primary_type
  | `Type_union_type of (type_ option * Token.t (* "|" *) * type_)
  | `Type_inte_type of (type_ option * Token.t (* "&" *) * type_)
  | `Type_func_type of (
        type_parameters option
      * formal_parameters
      * Token.t (* "=>" *)
      * type_
    )
  | `Type_cons_type of (
        Token.t (* "new" *)
      * type_parameters option
      * formal_parameters
      * Token.t (* "=>" *)
      * type_
    )
]
and primary_type = [
    `Prim_type_paren_type of (Token.t (* "(" *) * type_ * Token.t (* ")" *))
  | `Prim_type_pred_type of predefined_type
  | `Prim_type_id of identifier (*tok*)
  | `Prim_type_nest_type_id of nested_type_identifier
  | `Prim_type_gene_type of generic_type
  | `Prim_type_type_pred of (identifier (*tok*) * Token.t (* "is" *) * type_)
  | `Prim_type_obj_type of object_type
  | `Prim_type_array_type of (
        primary_type * Token.t (* "[" *) * Token.t (* "]" *)
    )
  | `Prim_type_tuple_type of (
        Token.t (* "[" *)
      * type_
      * (Token.t (* "," *) * type_) list (* zero or more *)
      * Token.t (* "]" *)
    )
  | `Prim_type_flow_maybe_type of (Token.t (* "?" *) * primary_type)
  | `Prim_type_type_query of (
        Token.t (* "typeof" *)
      * [ `Id of identifier (*tok*) | `Nest_id of nested_identifier ]
    )
  | `Prim_type_index_type_query of (
        Token.t (* "keyof" *)
      * [
            `Id of identifier (*tok*)
          | `Nest_type_id of nested_type_identifier
        ]
    )
  | `Prim_type_this of Token.t (* "this" *)
  | `Prim_type_exis_type of Token.t (* "*" *)
  | `Prim_type_lit_type of literal_type
  | `Prim_type_look_type of (
        primary_type * Token.t (* "[" *) * type_ * Token.t (* "]" *)
    )
]
and generic_type = (
    [ `Id of identifier (*tok*) | `Nest_type_id of nested_type_identifier ]
  * type_arguments
)
and mapped_type_clause = (identifier (*tok*) * Token.t (* "in" *) * type_)
and type_arguments = (
    Token.t (* "<" *)
  * type_
  * (Token.t (* "," *) * type_) list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t (* ">" *)
)
and object_type = (
    [ `LCURL of Token.t (* "{" *) | `LCURLBAR of Token.t (* "{|" *) ]
  * (
        [ `COMMA of Token.t (* "," *) | `SEMI of Token.t (* ";" *) ] option
      * [
            `Expo_stmt of export_statement
          | `Prop_sign of property_signature
          | `Call_sign_ of call_signature_
          | `Cons_sign of construct_signature
          | `Index_sign of index_signature
          | `Meth_sign of method_signature
        ]
      * (
            [
                `COMMA of Token.t (* "," *)
              | `Choice_auto_semi of [
                    `Auto_semi of automatic_semicolon (*tok*)
                  | `SEMI of Token.t (* ";" *)
                ]
            ]
          * [
                `Expo_stmt of export_statement
              | `Prop_sign of property_signature
              | `Call_sign_ of call_signature_
              | `Cons_sign of construct_signature
              | `Index_sign of index_signature
              | `Meth_sign of method_signature
            ]
        )
          list (* zero or more *)
      * [
            `COMMA of Token.t (* "," *)
          | `Choice_auto_semi of [
                `Auto_semi of automatic_semicolon (*tok*)
              | `SEMI of Token.t (* ";" *)
            ]
        ]
          option
    )
      option
  * [ `RCURL of Token.t (* "}" *) | `BARRCURL of Token.t (* "|}" *) ]
)
and call_signature_ = call_signature
and property_signature = (
    accessibility_modifier option
  * Token.t (* "static" *) option
  * Token.t (* "readonly" *) option
  * property_name
  * Token.t (* "?" *) option
  * type_annotation option
)
and type_parameters = (
    Token.t (* "<" *)
  * type_parameter
  * (Token.t (* "," *) * type_parameter) list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t (* ">" *)
)
and type_parameter = (
    identifier (*tok*)
  * constraint_ option
  * default_type option
)
and default_type = (Token.t (* "=" *) * type_)
and constraint_ = (
    [ `Extens of Token.t (* "extends" *) | `COLON of Token.t (* ":" *) ]
  * type_
)
and construct_signature = (
    Token.t (* "new" *)
  * type_parameters option
  * formal_parameters
  * type_annotation option
)
and index_signature = (
    Token.t (* "[" *)
  * [
        `Choice_id_COLON_pred_type of (
            [
                `Id of identifier (*tok*)
              | `Choice_decl of [
                    `Decl of Token.t (* "declare" *)
                  | `Name of Token.t (* "namespace" *)
                  | `Type of Token.t (* "type" *)
                  | `Publ of Token.t (* "public" *)
                  | `Priv of Token.t (* "private" *)
                  | `Prot of Token.t (* "protected" *)
                  | `Read of Token.t (* "readonly" *)
                  | `Modu of Token.t (* "module" *)
                  | `Any of Token.t (* "any" *)
                  | `Num of Token.t (* "number" *)
                  | `Bool of Token.t (* "boolean" *)
                  | `Str of Token.t (* "string" *)
                  | `Symb of Token.t (* "symbol" *)
                  | `Void of Token.t (* "void" *)
                  | `Expo of Token.t (* "export" *)
                  | `Choice_get of [
                        `Get of Token.t (* "get" *)
                      | `Set of Token.t (* "set" *)
                      | `Async of Token.t (* "async" *)
                      | `Stat of Token.t (* "static" *)
                    ]
                ]
            ]
          * Token.t (* ":" *)
          * predefined_type
        )
      | `Mapp_type_clau of mapped_type_clause
    ]
  * Token.t (* "]" *)
  * type_annotation
)
[@@deriving sexp_of]

type jsx_expression = (
    Token.t (* "{" *)
  * [
        `Exp of expression
      | `Seq_exp of sequence_expression
      | `Spre_elem of spread_element
    ]
      option
  * Token.t (* "}" *)
)
[@@deriving sexp_of]

type program = (
    hash_bang_line (*tok*) option
  * [
        `Expo_stmt of export_statement
      | `Impo_stmt of import_statement
      | `Debu_stmt of debugger_statement
      | `Exp_stmt of expression_statement
      | `Decl of declaration
      | `Stmt_blk of statement_block
      | `If_stmt of if_statement
      | `Swit_stmt of switch_statement
      | `For_stmt of for_statement
      | `For_in_stmt of for_in_statement
      | `While_stmt of while_statement
      | `Do_stmt of do_statement
      | `Try_stmt of try_statement
      | `With_stmt of with_statement
      | `Brk_stmt of break_statement
      | `Cont_stmt of continue_statement
      | `Ret_stmt of return_statement
      | `Throw_stmt of throw_statement
      | `Empty_stmt of Token.t (* ";" *)
      | `Labe_stmt of labeled_statement
    ]
      list (* zero or more *)
)
[@@deriving sexp_of]

type jsx_element = (
    jsx_opening_element
  * [
        `Jsx_text of jsx_text (*tok*)
      | `Choice_jsx_elem of [
            `Jsx_elem of jsx_element
          | `Jsx_self_clos_elem of jsx_self_closing_element
        ]
      | `Jsx_exp of jsx_expression
    ]
      list (* zero or more *)
  * jsx_closing_element
)
and jsx_fragment = (
    Token.t (* "<" *)
  * Token.t (* ">" *)
  * [
        `Jsx_text of jsx_text (*tok*)
      | `Choice_jsx_elem of [
            `Jsx_elem of jsx_element
          | `Jsx_self_clos_elem of jsx_self_closing_element
        ]
      | `Jsx_exp of jsx_expression
    ]
      list (* zero or more *)
  * Token.t (* "<" *)
  * Token.t (* "/" *)
  * Token.t (* ">" *)
)
and jsx_opening_element = (
    Token.t (* "<" *)
  * [
        `Choice_choice_jsx_id of [
            `Choice_jsx_id of [
                `Jsx_id of jsx_identifier (*tok*)
              | `Id of identifier (*tok*)
            ]
          | `Jsx_name_name of jsx_namespace_name
        ]
      | `Choice_id_opt_type_args of (
            [ `Id of identifier (*tok*) | `Nest_id of nested_identifier ]
          * type_arguments option
        )
    ]
  * [ `Jsx_attr of jsx_attribute | `Jsx_exp of jsx_expression ]
      list (* zero or more *)
  * Token.t (* ">" *)
)
and jsx_self_closing_element = (
    Token.t (* "<" *)
  * [
        `Choice_jsx_id of [
            `Jsx_id of jsx_identifier (*tok*)
          | `Id of identifier (*tok*)
        ]
      | `Nest_id of nested_identifier
      | `Jsx_name_name of jsx_namespace_name
    ]
  * [ `Jsx_attr of jsx_attribute | `Jsx_exp of jsx_expression ]
      list (* zero or more *)
  * Token.t (* "/" *)
  * Token.t (* ">" *)
)
and jsx_attribute = (
    [
        `Choice_jsx_id of [
            `Jsx_id of jsx_identifier (*tok*)
          | `Id of identifier (*tok*)
        ]
      | `Jsx_name_name of jsx_namespace_name
    ]
  * (
        Token.t (* "=" *)
      * [
            `Str of string_
          | `Jsx_exp of jsx_expression
          | `Choice_jsx_elem of [
                `Jsx_elem of jsx_element
              | `Jsx_self_clos_elem of jsx_self_closing_element
            ]
          | `Jsx_frag of jsx_fragment
        ]
    )
      option
)
[@@deriving sexp_of]

type existential_type (* inlined *) = Token.t (* "*" *)
[@@deriving sexp_of]

type readonly (* inlined *) = Token.t (* "readonly" *)
[@@deriving sexp_of]

type empty_statement (* inlined *) = Token.t (* ";" *)
[@@deriving sexp_of]

type this (* inlined *) = Token.t (* "this" *)
[@@deriving sexp_of]

type null (* inlined *) = Token.t (* "null" *)
[@@deriving sexp_of]

type false_ (* inlined *) = Token.t (* "false" *)
[@@deriving sexp_of]

type comment (* inlined *) = Token.t
[@@deriving sexp_of]

type undefined (* inlined *) = Token.t (* "undefined" *)
[@@deriving sexp_of]

type super (* inlined *) = Token.t (* "super" *)
[@@deriving sexp_of]

type true_ (* inlined *) = Token.t (* "true" *)
[@@deriving sexp_of]

type number_ (* inlined *) = (
    [ `DASH of Token.t (* "-" *) | `PLUS of Token.t (* "+" *) ]
  * number (*tok*)
)
[@@deriving sexp_of]

type type_query (* inlined *) = (
    Token.t (* "typeof" *)
  * [ `Id of identifier (*tok*) | `Nest_id of nested_identifier ]
)
[@@deriving sexp_of]

type import_alias (* inlined *) = (
    Token.t (* "import" *)
  * identifier (*tok*)
  * Token.t (* "=" *)
  * [ `Id of identifier (*tok*) | `Nest_id of nested_identifier ]
  * [
        `Auto_semi of automatic_semicolon (*tok*)
      | `SEMI of Token.t (* ";" *)
    ]
)
[@@deriving sexp_of]

type index_type_query (* inlined *) = (
    Token.t (* "keyof" *)
  * [ `Id of identifier (*tok*) | `Nest_type_id of nested_type_identifier ]
)
[@@deriving sexp_of]

type yield_expression (* inlined *) = (
    Token.t (* "yield" *)
  * [
        `STAR_exp of (Token.t (* "*" *) * expression)
      | `Opt_exp of expression option
    ]
)
[@@deriving sexp_of]

type call_expression (* inlined *) = (
    [
        `Exp of expression
      | `Super of Token.t (* "super" *)
      | `Func of function_
    ]
  * type_arguments option
  * [ `Args of arguments | `Temp_str of template_string ]
)
[@@deriving sexp_of]

type await_expression (* inlined *) = (Token.t (* "await" *) * expression)
[@@deriving sexp_of]

type assignment_expression (* inlined *) = (
    [
        `Paren_exp of parenthesized_expression
      | `Choice_memb_exp of [
            `Memb_exp of member_expression
          | `Subs_exp of subscript_expression
          | `Id of identifier (*tok*)
          | `Choice_decl of [
                `Decl of Token.t (* "declare" *)
              | `Name of Token.t (* "namespace" *)
              | `Type of Token.t (* "type" *)
              | `Publ of Token.t (* "public" *)
              | `Priv of Token.t (* "private" *)
              | `Prot of Token.t (* "protected" *)
              | `Read of Token.t (* "readonly" *)
              | `Modu of Token.t (* "module" *)
              | `Any of Token.t (* "any" *)
              | `Num of Token.t (* "number" *)
              | `Bool of Token.t (* "boolean" *)
              | `Str of Token.t (* "string" *)
              | `Symb of Token.t (* "symbol" *)
              | `Void of Token.t (* "void" *)
              | `Expo of Token.t (* "export" *)
              | `Choice_get of [
                    `Get of Token.t (* "get" *)
                  | `Set of Token.t (* "set" *)
                  | `Async of Token.t (* "async" *)
                  | `Stat of Token.t (* "static" *)
                ]
            ]
          | `Choice_obj of [ `Obj of object_ | `Array of array_ ]
        ]
    ]
  * Token.t (* "=" *)
  * expression
)
[@@deriving sexp_of]

type augmented_assignment_expression (* inlined *) = (
    [
        `Memb_exp of member_expression
      | `Subs_exp of subscript_expression
      | `Choice_decl of [
            `Decl of Token.t (* "declare" *)
          | `Name of Token.t (* "namespace" *)
          | `Type of Token.t (* "type" *)
          | `Publ of Token.t (* "public" *)
          | `Priv of Token.t (* "private" *)
          | `Prot of Token.t (* "protected" *)
          | `Read of Token.t (* "readonly" *)
          | `Modu of Token.t (* "module" *)
          | `Any of Token.t (* "any" *)
          | `Num of Token.t (* "number" *)
          | `Bool of Token.t (* "boolean" *)
          | `Str of Token.t (* "string" *)
          | `Symb of Token.t (* "symbol" *)
          | `Void of Token.t (* "void" *)
          | `Expo of Token.t (* "export" *)
          | `Choice_get of [
                `Get of Token.t (* "get" *)
              | `Set of Token.t (* "set" *)
              | `Async of Token.t (* "async" *)
              | `Stat of Token.t (* "static" *)
            ]
        ]
      | `Id of identifier (*tok*)
      | `Paren_exp of parenthesized_expression
    ]
  * [
        `PLUSEQ of Token.t (* "+=" *)
      | `DASHEQ of Token.t (* "-=" *)
      | `STAREQ of Token.t (* "*=" *)
      | `SLASHEQ of Token.t (* "/=" *)
      | `PERCEQ of Token.t (* "%=" *)
      | `HATEQ of Token.t (* "^=" *)
      | `AMPEQ of Token.t (* "&=" *)
      | `BAREQ of Token.t (* "|=" *)
      | `GTGTEQ of Token.t (* ">>=" *)
      | `GTGTGTEQ of Token.t (* ">>>=" *)
      | `LTLTEQ of Token.t (* "<<=" *)
      | `STARSTAREQ of Token.t (* "**=" *)
    ]
  * expression
)
[@@deriving sexp_of]

type ternary_expression (* inlined *) = (
    expression * Token.t (* "?" *) * expression * Token.t (* ":" *)
  * expression
)
[@@deriving sexp_of]

type computed_property_name (* inlined *) = (
    Token.t (* "[" *) * expression * Token.t (* "]" *)
)
[@@deriving sexp_of]

type non_null_expression (* inlined *) = (expression * Token.t (* "!" *))
[@@deriving sexp_of]

type function_signature (* inlined *) = (
    Token.t (* "async" *) option
  * Token.t (* "function" *)
  * identifier (*tok*)
  * call_signature
  * [
        `Auto_semi of automatic_semicolon (*tok*)
      | `SEMI of Token.t (* ";" *)
    ]
)
[@@deriving sexp_of]

type type_assertion (* inlined *) = (type_arguments * expression)
[@@deriving sexp_of]

type as_expression (* inlined *) = (
    expression
  * Token.t (* "as" *)
  * [ `Type of type_ | `Temp_str of template_string ]
)
[@@deriving sexp_of]

type ambient_declaration (* inlined *) = (
    Token.t (* "declare" *)
  * [
        `Decl of declaration
      | `Glob_stmt_blk of (Token.t (* "global" *) * statement_block)
      | `Modu_DOT_id_COLON_type of (
            Token.t (* "module" *) * Token.t (* "." *) * identifier (*tok*)
          * Token.t (* ":" *) * type_
        )
    ]
)
[@@deriving sexp_of]

type abstract_class_declaration (* inlined *) = (
    Token.t (* "abstract" *)
  * Token.t (* "class" *)
  * identifier (*tok*)
  * type_parameters option
  * class_heritage option
  * class_body
)
[@@deriving sexp_of]

type module_ (* inlined *) = (Token.t (* "module" *) * module__)
[@@deriving sexp_of]

type interface_declaration (* inlined *) = (
    Token.t (* "interface" *)
  * identifier (*tok*)
  * type_parameters option
  * extends_clause option
  * object_type
)
[@@deriving sexp_of]

type enum_declaration (* inlined *) = (
    Token.t (* "const" *) option
  * Token.t (* "enum" *)
  * identifier (*tok*)
  * enum_body
)
[@@deriving sexp_of]

type type_alias_declaration (* inlined *) = (
    Token.t (* "type" *)
  * identifier (*tok*)
  * type_parameters option
  * Token.t (* "=" *)
  * type_
  * [
        `Auto_semi of automatic_semicolon (*tok*)
      | `SEMI of Token.t (* ";" *)
    ]
)
[@@deriving sexp_of]

type constructor_type (* inlined *) = (
    Token.t (* "new" *)
  * type_parameters option
  * formal_parameters
  * Token.t (* "=>" *)
  * type_
)
[@@deriving sexp_of]

type type_predicate (* inlined *) = (
    identifier (*tok*) * Token.t (* "is" *) * type_
)
[@@deriving sexp_of]

type lookup_type (* inlined *) = (
    primary_type * Token.t (* "[" *) * type_ * Token.t (* "]" *)
)
[@@deriving sexp_of]

type flow_maybe_type (* inlined *) = (Token.t (* "?" *) * primary_type)
[@@deriving sexp_of]

type parenthesized_type (* inlined *) = (
    Token.t (* "(" *) * type_ * Token.t (* ")" *)
)
[@@deriving sexp_of]

type array_type (* inlined *) = (
    primary_type * Token.t (* "[" *) * Token.t (* "]" *)
)
[@@deriving sexp_of]

type tuple_type (* inlined *) = (
    Token.t (* "[" *)
  * type_
  * (Token.t (* "," *) * type_) list (* zero or more *)
  * Token.t (* "]" *)
)
[@@deriving sexp_of]

type union_type (* inlined *) = (type_ option * Token.t (* "|" *) * type_)
[@@deriving sexp_of]

type intersection_type (* inlined *) = (
    type_ option
  * Token.t (* "&" *)
  * type_
)
[@@deriving sexp_of]

type function_type (* inlined *) = (
    type_parameters option
  * formal_parameters
  * Token.t (* "=>" *)
  * type_
)
[@@deriving sexp_of]

let dump_tree root =
  sexp_of_program root
  |> Print_sexp.to_stdout
